import {
  CompositeList,
  getDisabledMountTransitionStyles,
  getPseudoElementBounds,
  useAnchorPositioning,
  useCompositeListItem,
  useDirection,
  useToolbarRootContext
} from "./chunk-Q5RIAEQM.js";
import {
  useControlled
} from "./chunk-XTTFSCSO.js";
import {
  COMPOSITE_KEYS,
  FloatingFocusManager,
  FloatingNode,
  FloatingPortal,
  FloatingTree,
  FloatingTreeStore,
  FocusGuard,
  InternalBackdrop,
  PopupTriggerMap,
  ReactStore,
  createInitialPopupStoreState,
  createSelector,
  inertValue,
  popupStateMapping,
  popupStoreSelectors,
  pressableTriggerOpenStateMapping,
  safePolygon,
  transitionStatusMapping,
  triggerOpenStateMapping,
  useAnimationFrame,
  useClick,
  useDismiss,
  useFloatingNodeId,
  useFloatingParentNodeId,
  useFloatingTree,
  useFocus,
  useHoverFloatingInteraction,
  useHoverReferenceInteraction,
  useImplicitActiveTrigger,
  useInteractions,
  useListNavigation,
  useOpenChangeComplete,
  useOpenInteractionType,
  useOpenStateTransitions,
  useRole,
  useScrollLock,
  useSyncedFloatingRootContext,
  useTransitionStatus,
  useTriggerDataForwarding,
  useTriggerRegistration,
  useTypeahead
} from "./chunk-2SRFESJV.js";
import {
  useButton,
  useCompositeRootContext
} from "./chunk-MYLPGJIA.js";
import {
  contains,
  createChangeEventDetails,
  getNextTabbable,
  getTabbableAfterElement,
  getTabbableBeforeElement,
  isOutsideEvent,
  ownerDocument,
  reason_parts_exports,
  useBaseUiId,
  useId,
  useTimeout
} from "./chunk-SFCZYUXY.js";
import {
  getParentNode,
  isHTMLElement,
  isLastTraversableNode,
  useIsoLayoutEffect,
  useStableCallback
} from "./chunk-IPVTD4HP.js";
import {
  require_react_dom
} from "./chunk-IWOBEF4E.js";
import {
  require_jsx_runtime
} from "./chunk-7HXCKB66.js";
import {
  Separator
} from "./chunk-WOEIYL44.js";
import {
  DROPDOWN_COLLISION_AVOIDANCE,
  EMPTY_ARRAY,
  EMPTY_OBJECT,
  PATIENT_CLICK_THRESHOLD,
  POPUP_COLLISION_AVOIDANCE,
  TYPEAHEAD_RESET_MS,
  useMergedRefs,
  useRefWithInit,
  useRenderElement
} from "./chunk-LMVQTOSF.js";
import {
  mergeProps
} from "./chunk-ZRAMOAJZ.js";
import {
  require_react
} from "./chunk-RY7GF66K.js";
import {
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@base-ui/react/esm/menu/index.parts.js
var index_parts_exports = {};
__export(index_parts_exports, {
  Arrow: () => MenuArrow,
  Backdrop: () => MenuBackdrop,
  CheckboxItem: () => MenuCheckboxItem,
  CheckboxItemIndicator: () => MenuCheckboxItemIndicator,
  Group: () => MenuGroup,
  GroupLabel: () => MenuGroupLabel,
  Handle: () => MenuHandle,
  Item: () => MenuItem,
  Popup: () => MenuPopup,
  Portal: () => MenuPortal,
  Positioner: () => MenuPositioner,
  RadioGroup: () => MenuRadioGroup,
  RadioItem: () => MenuRadioItem,
  RadioItemIndicator: () => MenuRadioItemIndicator,
  Root: () => MenuRoot,
  Separator: () => Separator,
  SubmenuRoot: () => MenuSubmenuRoot,
  SubmenuTrigger: () => MenuSubmenuTrigger,
  Trigger: () => MenuTrigger,
  createHandle: () => createMenuHandle
});

// node_modules/@base-ui/react/esm/menu/arrow/MenuArrow.js
var React3 = __toESM(require_react(), 1);

// node_modules/@base-ui/react/esm/menu/positioner/MenuPositionerContext.js
var React = __toESM(require_react(), 1);
var MenuPositionerContext = React.createContext(void 0);
if (true) MenuPositionerContext.displayName = "MenuPositionerContext";
function useMenuPositionerContext(optional) {
  const context = React.useContext(MenuPositionerContext);
  if (context === void 0 && !optional) {
    throw new Error(true ? "Base UI: MenuPositionerContext is missing. MenuPositioner parts must be placed within <Menu.Positioner>." : formatErrorMessage(33));
  }
  return context;
}

// node_modules/@base-ui/react/esm/menu/root/MenuRootContext.js
var React2 = __toESM(require_react(), 1);
var MenuRootContext = React2.createContext(void 0);
if (true) MenuRootContext.displayName = "MenuRootContext";
function useMenuRootContext(optional) {
  const context = React2.useContext(MenuRootContext);
  if (context === void 0 && !optional) {
    throw new Error(true ? "Base UI: MenuRootContext is missing. Menu parts must be placed within <Menu.Root>." : formatErrorMessage(36));
  }
  return context;
}

// node_modules/@base-ui/react/esm/menu/arrow/MenuArrow.js
var MenuArrow = React3.forwardRef(function MenuArrow2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useMenuRootContext();
  const {
    arrowRef,
    side,
    align,
    arrowUncentered,
    arrowStyles
  } = useMenuPositionerContext();
  const open = store.useState("open");
  const state = React3.useMemo(() => ({
    open,
    side,
    align,
    uncentered: arrowUncentered
  }), [open, side, align, arrowUncentered]);
  return useRenderElement("div", componentProps, {
    ref: [arrowRef, forwardedRef],
    stateAttributesMapping: popupStateMapping,
    state,
    props: {
      style: arrowStyles,
      "aria-hidden": true,
      ...elementProps
    }
  });
});
if (true) MenuArrow.displayName = "MenuArrow";

// node_modules/@base-ui/react/esm/menu/backdrop/MenuBackdrop.js
var React5 = __toESM(require_react(), 1);

// node_modules/@base-ui/react/esm/context-menu/root/ContextMenuRootContext.js
var React4 = __toESM(require_react(), 1);
var ContextMenuRootContext = React4.createContext(void 0);
if (true) ContextMenuRootContext.displayName = "ContextMenuRootContext";
function useContextMenuRootContext(optional = true) {
  const context = React4.useContext(ContextMenuRootContext);
  if (context === void 0 && !optional) {
    throw new Error(true ? "Base UI: ContextMenuRootContext is missing. ContextMenu parts must be placed within <ContextMenu.Root>." : formatErrorMessage(25));
  }
  return context;
}

// node_modules/@base-ui/react/esm/menu/backdrop/MenuBackdrop.js
var stateAttributesMapping = {
  ...popupStateMapping,
  ...transitionStatusMapping
};
var MenuBackdrop = React5.forwardRef(function MenuBackdrop2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useMenuRootContext();
  const open = store.useState("open");
  const mounted = store.useState("mounted");
  const transitionStatus = store.useState("transitionStatus");
  const lastOpenChangeReason = store.useState("lastOpenChangeReason");
  const contextMenuContext = useContextMenuRootContext();
  const state = React5.useMemo(() => ({
    open,
    transitionStatus
  }), [open, transitionStatus]);
  return useRenderElement("div", componentProps, {
    ref: contextMenuContext?.backdropRef ? [forwardedRef, contextMenuContext.backdropRef] : forwardedRef,
    state,
    stateAttributesMapping,
    props: [{
      role: "presentation",
      hidden: !mounted,
      style: {
        pointerEvents: lastOpenChangeReason === reason_parts_exports.triggerHover ? "none" : void 0,
        userSelect: "none",
        WebkitUserSelect: "none"
      }
    }, elementProps]
  });
});
if (true) MenuBackdrop.displayName = "MenuBackdrop";

// node_modules/@base-ui/react/esm/menu/checkbox-item/MenuCheckboxItem.js
var React8 = __toESM(require_react(), 1);

// node_modules/@base-ui/react/esm/menu/checkbox-item/MenuCheckboxItemContext.js
var React6 = __toESM(require_react(), 1);
var MenuCheckboxItemContext = React6.createContext(void 0);
if (true) MenuCheckboxItemContext.displayName = "MenuCheckboxItemContext";
function useMenuCheckboxItemContext() {
  const context = React6.useContext(MenuCheckboxItemContext);
  if (context === void 0) {
    throw new Error(true ? "Base UI: MenuCheckboxItemContext is missing. MenuCheckboxItem parts must be placed within <Menu.CheckboxItem>." : formatErrorMessage(30));
  }
  return context;
}

// node_modules/@base-ui/react/esm/menu/item/useMenuItem.js
var React7 = __toESM(require_react(), 1);
var REGULAR_ITEM = {
  type: "regular-item"
};
function useMenuItem(params) {
  const {
    closeOnClick,
    disabled = false,
    highlighted,
    id,
    store,
    nativeButton,
    itemMetadata,
    nodeId
  } = params;
  const itemRef = React7.useRef(null);
  const contextMenuContext = useContextMenuRootContext(true);
  const isContextMenu = contextMenuContext !== void 0;
  const {
    events: menuEvents
  } = store.useState("floatingTreeRoot");
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    focusableWhenDisabled: true,
    native: nativeButton
  });
  const getItemProps = React7.useCallback((externalProps) => {
    return mergeProps({
      id,
      role: "menuitem",
      tabIndex: highlighted ? 0 : -1,
      onMouseMove(event) {
        if (!nodeId) {
          return;
        }
        menuEvents.emit("itemhover", {
          nodeId,
          target: event.currentTarget
        });
      },
      onMouseEnter() {
        if (itemMetadata.type !== "submenu-trigger") {
          return;
        }
        itemMetadata.setActive();
      },
      onKeyUp(event) {
        if (event.key === " " && store.context.typingRef.current) {
          event.preventBaseUIHandler();
        }
      },
      onClick(event) {
        if (closeOnClick) {
          menuEvents.emit("close", {
            domEvent: event,
            reason: reason_parts_exports.itemPress
          });
        }
      },
      onMouseUp(event) {
        if (contextMenuContext) {
          const initialCursorPoint = contextMenuContext.initialCursorPointRef.current;
          contextMenuContext.initialCursorPointRef.current = null;
          if (isContextMenu && initialCursorPoint && Math.abs(event.clientX - initialCursorPoint.x) <= 1 && Math.abs(event.clientY - initialCursorPoint.y) <= 1) {
            return;
          }
        }
        if (itemRef.current && store.context.allowMouseUpTriggerRef.current && (!isContextMenu || event.button === 2)) {
          if (itemMetadata.type === "regular-item") {
            itemRef.current.click();
          }
        }
      }
    }, externalProps, getButtonProps);
  }, [id, highlighted, getButtonProps, closeOnClick, menuEvents, store, isContextMenu, contextMenuContext, itemMetadata, nodeId]);
  const mergedRef = useMergedRefs(itemRef, buttonRef);
  return React7.useMemo(() => ({
    getItemProps,
    itemRef: mergedRef
  }), [getItemProps, mergedRef]);
}

// node_modules/@base-ui/react/esm/menu/checkbox-item/MenuCheckboxItemDataAttributes.js
var MenuCheckboxItemDataAttributes = (function(MenuCheckboxItemDataAttributes2) {
  MenuCheckboxItemDataAttributes2["checked"] = "data-checked";
  MenuCheckboxItemDataAttributes2["unchecked"] = "data-unchecked";
  MenuCheckboxItemDataAttributes2["disabled"] = "data-disabled";
  MenuCheckboxItemDataAttributes2["highlighted"] = "data-highlighted";
  return MenuCheckboxItemDataAttributes2;
})({});

// node_modules/@base-ui/react/esm/menu/utils/stateAttributesMapping.js
var itemMapping = {
  checked(value) {
    if (value) {
      return {
        [MenuCheckboxItemDataAttributes.checked]: ""
      };
    }
    return {
      [MenuCheckboxItemDataAttributes.unchecked]: ""
    };
  },
  ...transitionStatusMapping
};

// node_modules/@base-ui/react/esm/menu/checkbox-item/MenuCheckboxItem.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var MenuCheckboxItem = React8.forwardRef(function MenuCheckboxItem2(componentProps, forwardedRef) {
  const {
    render,
    className,
    id: idProp,
    label,
    nativeButton = false,
    disabled = false,
    closeOnClick = false,
    checked: checkedProp,
    defaultChecked,
    onCheckedChange,
    ...elementProps
  } = componentProps;
  const listItem = useCompositeListItem({
    label
  });
  const menuPositionerContext = useMenuPositionerContext(true);
  const id = useBaseUiId(idProp);
  const {
    store
  } = useMenuRootContext();
  const highlighted = store.useState("isActive", listItem.index);
  const itemProps = store.useState("itemProps");
  const [checked, setChecked] = useControlled({
    controlled: checkedProp,
    default: defaultChecked ?? false,
    name: "MenuCheckboxItem",
    state: "checked"
  });
  const {
    getItemProps,
    itemRef
  } = useMenuItem({
    closeOnClick,
    disabled,
    highlighted,
    id,
    store,
    nativeButton,
    nodeId: menuPositionerContext?.nodeId,
    itemMetadata: REGULAR_ITEM
  });
  const state = React8.useMemo(() => ({
    disabled,
    highlighted,
    checked
  }), [disabled, highlighted, checked]);
  const handleClick = useStableCallback((event) => {
    const details = {
      ...createChangeEventDetails(reason_parts_exports.itemPress, event.nativeEvent),
      preventUnmountOnClose: () => {
      }
    };
    onCheckedChange?.(!checked, details);
    if (details.isCanceled) {
      return;
    }
    setChecked((currentlyChecked) => !currentlyChecked);
  });
  const element = useRenderElement("div", componentProps, {
    state,
    stateAttributesMapping: itemMapping,
    props: [itemProps, {
      role: "menuitemcheckbox",
      "aria-checked": checked,
      onClick: handleClick
    }, elementProps, getItemProps],
    ref: [itemRef, forwardedRef, listItem.ref]
  });
  return (0, import_jsx_runtime.jsx)(MenuCheckboxItemContext.Provider, {
    value: state,
    children: element
  });
});
if (true) MenuCheckboxItem.displayName = "MenuCheckboxItem";

// node_modules/@base-ui/react/esm/menu/checkbox-item-indicator/MenuCheckboxItemIndicator.js
var React9 = __toESM(require_react(), 1);
var MenuCheckboxItemIndicator = React9.forwardRef(function MenuCheckboxItemIndicator2(componentProps, forwardedRef) {
  const {
    render,
    className,
    keepMounted = false,
    ...elementProps
  } = componentProps;
  const item = useMenuCheckboxItemContext();
  const indicatorRef = React9.useRef(null);
  const {
    transitionStatus,
    setMounted
  } = useTransitionStatus(item.checked);
  useOpenChangeComplete({
    open: item.checked,
    ref: indicatorRef,
    onComplete() {
      if (!item.checked) {
        setMounted(false);
      }
    }
  });
  const state = React9.useMemo(() => ({
    checked: item.checked,
    disabled: item.disabled,
    highlighted: item.highlighted,
    transitionStatus
  }), [item.checked, item.disabled, item.highlighted, transitionStatus]);
  const element = useRenderElement("span", componentProps, {
    state,
    ref: [forwardedRef, indicatorRef],
    stateAttributesMapping: itemMapping,
    props: {
      "aria-hidden": true,
      ...elementProps
    },
    enabled: keepMounted || item.checked
  });
  return element;
});
if (true) MenuCheckboxItemIndicator.displayName = "MenuCheckboxItemIndicator";

// node_modules/@base-ui/react/esm/menu/group/MenuGroup.js
var React11 = __toESM(require_react(), 1);

// node_modules/@base-ui/react/esm/menu/group/MenuGroupContext.js
var React10 = __toESM(require_react(), 1);
var MenuGroupContext = React10.createContext(void 0);
if (true) MenuGroupContext.displayName = "MenuGroupContext";
function useMenuGroupRootContext() {
  const context = React10.useContext(MenuGroupContext);
  if (context === void 0) {
    throw new Error(true ? "Base UI: MenuGroupRootContext is missing. Menu group parts must be used within <Menu.Group>." : formatErrorMessage(31));
  }
  return context;
}

// node_modules/@base-ui/react/esm/menu/group/MenuGroup.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var MenuGroup = React11.forwardRef(function MenuGroup2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const [labelId, setLabelId] = React11.useState(void 0);
  const context = React11.useMemo(() => ({
    setLabelId
  }), [setLabelId]);
  const element = useRenderElement("div", componentProps, {
    ref: forwardedRef,
    props: {
      role: "group",
      "aria-labelledby": labelId,
      ...elementProps
    }
  });
  return (0, import_jsx_runtime2.jsx)(MenuGroupContext.Provider, {
    value: context,
    children: element
  });
});
if (true) MenuGroup.displayName = "MenuGroup";

// node_modules/@base-ui/react/esm/menu/group-label/MenuGroupLabel.js
var React12 = __toESM(require_react(), 1);
var MenuGroupLabel = React12.forwardRef(function MenuGroupLabelComponent(componentProps, forwardedRef) {
  const {
    className,
    render,
    id: idProp,
    ...elementProps
  } = componentProps;
  const id = useBaseUiId(idProp);
  const {
    setLabelId
  } = useMenuGroupRootContext();
  useIsoLayoutEffect(() => {
    setLabelId(id);
    return () => {
      setLabelId(void 0);
    };
  }, [setLabelId, id]);
  return useRenderElement("div", componentProps, {
    ref: forwardedRef,
    props: {
      id,
      role: "presentation",
      ...elementProps
    }
  });
});
if (true) MenuGroupLabel.displayName = "MenuGroupLabel";

// node_modules/@base-ui/react/esm/menu/item/MenuItem.js
var React13 = __toESM(require_react(), 1);
var MenuItem = React13.forwardRef(function MenuItem2(componentProps, forwardedRef) {
  const {
    render,
    className,
    id: idProp,
    label,
    nativeButton = false,
    disabled = false,
    closeOnClick = true,
    ...elementProps
  } = componentProps;
  const listItem = useCompositeListItem({
    label
  });
  const menuPositionerContext = useMenuPositionerContext(true);
  const id = useBaseUiId(idProp);
  const {
    store
  } = useMenuRootContext();
  const highlighted = store.useState("isActive", listItem.index);
  const itemProps = store.useState("itemProps");
  const {
    getItemProps,
    itemRef
  } = useMenuItem({
    closeOnClick,
    disabled,
    highlighted,
    id,
    store,
    nativeButton,
    nodeId: menuPositionerContext?.nodeId,
    itemMetadata: REGULAR_ITEM
  });
  const state = React13.useMemo(() => ({
    disabled,
    highlighted
  }), [disabled, highlighted]);
  return useRenderElement("div", componentProps, {
    state,
    props: [itemProps, elementProps, getItemProps],
    ref: [itemRef, forwardedRef, listItem.ref]
  });
});
if (true) MenuItem.displayName = "MenuItem";

// node_modules/@base-ui/react/esm/menu/popup/MenuPopup.js
var React14 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var stateAttributesMapping2 = {
  ...popupStateMapping,
  ...transitionStatusMapping
};
var MenuPopup = React14.forwardRef(function MenuPopup2(componentProps, forwardedRef) {
  const {
    render,
    className,
    finalFocus,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useMenuRootContext();
  const {
    side,
    align
  } = useMenuPositionerContext();
  const insideToolbar = useToolbarRootContext(true) != null;
  const open = store.useState("open");
  const transitionStatus = store.useState("transitionStatus");
  const popupProps = store.useState("popupProps");
  const mounted = store.useState("mounted");
  const instantType = store.useState("instantType");
  const triggerElement = store.useState("activeTriggerElement");
  const parent = store.useState("parent");
  const lastOpenChangeReason = store.useState("lastOpenChangeReason");
  const rootId = store.useState("rootId");
  const floatingContext = store.useState("floatingRootContext");
  const floatingTreeRoot = store.useState("floatingTreeRoot");
  const closeDelay = store.useState("closeDelay");
  const activeTriggerElement = store.useState("activeTriggerElement");
  const isContextMenu = parent.type === "context-menu";
  useOpenChangeComplete({
    open,
    ref: store.context.popupRef,
    onComplete() {
      if (open) {
        store.context.onOpenChangeComplete?.(true);
      }
    }
  });
  React14.useEffect(() => {
    function handleClose(event) {
      store.setOpen(false, createChangeEventDetails(event.reason, event.domEvent));
    }
    floatingTreeRoot.events.on("close", handleClose);
    return () => {
      floatingTreeRoot.events.off("close", handleClose);
    };
  }, [floatingTreeRoot.events, store]);
  const hoverEnabled = store.useState("hoverEnabled");
  const disabled = store.useState("disabled");
  useHoverFloatingInteraction(floatingContext, {
    enabled: hoverEnabled && !disabled && !isContextMenu && parent.type !== "menubar",
    closeDelay
  });
  const state = React14.useMemo(() => ({
    transitionStatus,
    side,
    align,
    open,
    nested: parent.type === "menu",
    instant: instantType
  }), [transitionStatus, side, align, open, parent.type, instantType]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, store.context.popupRef],
    stateAttributesMapping: stateAttributesMapping2,
    props: [popupProps, {
      onKeyDown(event) {
        if (insideToolbar && COMPOSITE_KEYS.has(event.key)) {
          event.stopPropagation();
        }
      }
    }, getDisabledMountTransitionStyles(transitionStatus), elementProps, {
      "data-rootownerid": rootId
    }]
  });
  let returnFocus = parent.type === void 0 || isContextMenu;
  if (triggerElement || parent.type === "menubar" && lastOpenChangeReason !== reason_parts_exports.outsidePress) {
    returnFocus = true;
  }
  return (0, import_jsx_runtime3.jsx)(FloatingFocusManager, {
    context: floatingContext,
    modal: isContextMenu,
    disabled: !mounted,
    returnFocus: finalFocus === void 0 ? returnFocus : finalFocus,
    initialFocus: parent.type !== "menu",
    restoreFocus: true,
    externalTree: parent.type !== "menubar" ? floatingTreeRoot : void 0,
    previousFocusableElement: activeTriggerElement,
    nextFocusableElement: parent.type === void 0 ? store.context.triggerFocusTargetRef : void 0,
    beforeContentFocusGuardRef: parent.type === void 0 ? store.context.beforeContentFocusGuardRef : void 0,
    children: element
  });
});
if (true) MenuPopup.displayName = "MenuPopup";

// node_modules/@base-ui/react/esm/menu/portal/MenuPortal.js
var React16 = __toESM(require_react(), 1);

// node_modules/@base-ui/react/esm/menu/portal/MenuPortalContext.js
var React15 = __toESM(require_react(), 1);
var MenuPortalContext = React15.createContext(void 0);
if (true) MenuPortalContext.displayName = "MenuPortalContext";
function useMenuPortalContext() {
  const value = React15.useContext(MenuPortalContext);
  if (value === void 0) {
    throw new Error(true ? "Base UI: <Menu.Portal> is missing." : formatErrorMessage(32));
  }
  return value;
}

// node_modules/@base-ui/react/esm/menu/portal/MenuPortal.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var MenuPortal = React16.forwardRef(function MenuPortal2(props, forwardedRef) {
  const {
    keepMounted = false,
    ...portalProps
  } = props;
  const {
    store
  } = useMenuRootContext();
  const mounted = store.useState("mounted");
  const shouldRender = mounted || keepMounted;
  if (!shouldRender) {
    return null;
  }
  return (0, import_jsx_runtime4.jsx)(MenuPortalContext.Provider, {
    value: keepMounted,
    children: (0, import_jsx_runtime4.jsx)(FloatingPortal, {
      ref: forwardedRef,
      ...portalProps
    })
  });
});
if (true) MenuPortal.displayName = "MenuPortal";

// node_modules/@base-ui/react/esm/menu/positioner/MenuPositioner.js
var React17 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var MenuPositioner = React17.forwardRef(function MenuPositioner2(componentProps, forwardedRef) {
  const {
    anchor: anchorProp,
    positionMethod: positionMethodProp = "absolute",
    className,
    render,
    side,
    align: alignProp,
    sideOffset: sideOffsetProp = 0,
    alignOffset: alignOffsetProp = 0,
    collisionBoundary = "clipping-ancestors",
    collisionPadding = 5,
    arrowPadding = 5,
    sticky = false,
    disableAnchorTracking = false,
    collisionAvoidance: collisionAvoidanceProp = DROPDOWN_COLLISION_AVOIDANCE,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useMenuRootContext();
  const keepMounted = useMenuPortalContext();
  const contextMenuContext = useContextMenuRootContext(true);
  const parent = store.useState("parent");
  const floatingRootContext = store.useState("floatingRootContext");
  const floatingTreeRoot = store.useState("floatingTreeRoot");
  const mounted = store.useState("mounted");
  const open = store.useState("open");
  const modal = store.useState("modal");
  const triggerElement = store.useState("activeTriggerElement");
  const lastOpenChangeReason = store.useState("lastOpenChangeReason");
  const floatingNodeId = store.useState("floatingNodeId");
  const floatingParentNodeId = store.useState("floatingParentNodeId");
  let anchor = anchorProp;
  let sideOffset = sideOffsetProp;
  let alignOffset = alignOffsetProp;
  let align = alignProp;
  let collisionAvoidance = collisionAvoidanceProp;
  if (parent.type === "context-menu") {
    anchor = anchorProp ?? parent.context?.anchor;
    align = align ?? "start";
    if (!side && align !== "center") {
      alignOffset = componentProps.alignOffset ?? 2;
      sideOffset = componentProps.sideOffset ?? -5;
    }
  }
  let computedSide = side;
  let computedAlign = align;
  if (parent.type === "menu") {
    computedSide = computedSide ?? "inline-end";
    computedAlign = computedAlign ?? "start";
    collisionAvoidance = componentProps.collisionAvoidance ?? POPUP_COLLISION_AVOIDANCE;
  } else if (parent.type === "menubar") {
    computedSide = computedSide ?? "bottom";
    computedAlign = computedAlign ?? "start";
  }
  const contextMenu = parent.type === "context-menu";
  const positioner = useAnchorPositioning({
    anchor,
    floatingRootContext,
    positionMethod: contextMenuContext ? "fixed" : positionMethodProp,
    mounted,
    side: computedSide,
    sideOffset,
    align: computedAlign,
    alignOffset,
    arrowPadding: contextMenu ? 0 : arrowPadding,
    collisionBoundary,
    collisionPadding,
    sticky,
    nodeId: floatingNodeId,
    keepMounted,
    disableAnchorTracking,
    collisionAvoidance,
    shiftCrossAxis: contextMenu,
    externalTree: floatingTreeRoot
  });
  const positionerProps = React17.useMemo(() => {
    const hiddenStyles = {};
    if (!open) {
      hiddenStyles.pointerEvents = "none";
    }
    return {
      role: "presentation",
      hidden: !mounted,
      style: {
        ...positioner.positionerStyles,
        ...hiddenStyles
      }
    };
  }, [open, mounted, positioner.positionerStyles]);
  React17.useEffect(() => {
    function onMenuOpenChange(details) {
      if (details.open) {
        if (details.parentNodeId === floatingNodeId) {
          store.set("hoverEnabled", false);
        }
        if (details.nodeId !== floatingNodeId && details.parentNodeId === store.select("floatingParentNodeId")) {
          store.setOpen(false, createChangeEventDetails(reason_parts_exports.siblingOpen));
        }
      } else if (details.parentNodeId === floatingNodeId) {
        if (details.reason !== reason_parts_exports.siblingOpen) {
          store.set("hoverEnabled", true);
        }
      }
    }
    floatingTreeRoot.events.on("menuopenchange", onMenuOpenChange);
    return () => {
      floatingTreeRoot.events.off("menuopenchange", onMenuOpenChange);
    };
  }, [store, floatingTreeRoot.events, floatingNodeId]);
  React17.useEffect(() => {
    if (store.select("floatingParentNodeId") == null) {
      return void 0;
    }
    function onParentClose(details) {
      if (details.open || details.nodeId !== store.select("floatingParentNodeId")) {
        return;
      }
      const reason = details.reason ?? reason_parts_exports.siblingOpen;
      store.setOpen(false, createChangeEventDetails(reason));
    }
    floatingTreeRoot.events.on("menuopenchange", onParentClose);
    return () => {
      floatingTreeRoot.events.off("menuopenchange", onParentClose);
    };
  }, [floatingTreeRoot.events, store]);
  React17.useEffect(() => {
    function onItemHover(event) {
      if (!open || event.nodeId !== store.select("floatingParentNodeId")) {
        return;
      }
      if (event.target && triggerElement && triggerElement !== event.target) {
        store.setOpen(false, createChangeEventDetails(reason_parts_exports.siblingOpen));
      }
    }
    floatingTreeRoot.events.on("itemhover", onItemHover);
    return () => {
      floatingTreeRoot.events.off("itemhover", onItemHover);
    };
  }, [floatingTreeRoot.events, open, triggerElement, store]);
  React17.useEffect(() => {
    const eventDetails = {
      open,
      nodeId: floatingNodeId,
      parentNodeId: floatingParentNodeId,
      reason: store.select("lastOpenChangeReason")
    };
    floatingTreeRoot.events.emit("menuopenchange", eventDetails);
  }, [floatingTreeRoot.events, open, store, floatingNodeId, floatingParentNodeId]);
  const state = React17.useMemo(() => ({
    open,
    side: positioner.side,
    align: positioner.align,
    anchorHidden: positioner.anchorHidden,
    nested: parent.type === "menu"
  }), [open, positioner.side, positioner.align, positioner.anchorHidden, parent.type]);
  const contextValue = React17.useMemo(() => ({
    side: positioner.side,
    align: positioner.align,
    arrowRef: positioner.arrowRef,
    arrowUncentered: positioner.arrowUncentered,
    arrowStyles: positioner.arrowStyles,
    nodeId: positioner.context.nodeId
  }), [positioner.side, positioner.align, positioner.arrowRef, positioner.arrowUncentered, positioner.arrowStyles, positioner.context.nodeId]);
  const element = useRenderElement("div", componentProps, {
    state,
    stateAttributesMapping: popupStateMapping,
    ref: [forwardedRef, store.useStateSetter("positionerElement")],
    props: [positionerProps, elementProps]
  });
  const shouldRenderBackdrop = mounted && parent.type !== "menu" && (parent.type !== "menubar" && modal && lastOpenChangeReason !== reason_parts_exports.triggerHover || parent.type === "menubar" && parent.context.modal);
  let backdropCutout = null;
  if (parent.type === "menubar") {
    backdropCutout = parent.context.contentElement;
  } else if (parent.type === void 0) {
    backdropCutout = triggerElement;
  }
  return (0, import_jsx_runtime5.jsxs)(MenuPositionerContext.Provider, {
    value: contextValue,
    children: [shouldRenderBackdrop && (0, import_jsx_runtime5.jsx)(InternalBackdrop, {
      ref: parent.type === "context-menu" || parent.type === "nested-context-menu" ? parent.context.internalBackdropRef : null,
      inert: inertValue(!open),
      cutout: backdropCutout
    }), (0, import_jsx_runtime5.jsx)(FloatingNode, {
      id: floatingNodeId,
      children: (0, import_jsx_runtime5.jsx)(CompositeList, {
        elementsRef: store.context.itemDomElements,
        labelsRef: store.context.itemLabels,
        children: element
      })
    })]
  });
});
if (true) MenuPositioner.displayName = "MenuPositioner";

// node_modules/@base-ui/react/esm/menu/radio-group/MenuRadioGroup.js
var React19 = __toESM(require_react(), 1);

// node_modules/@base-ui/react/esm/menu/radio-group/MenuRadioGroupContext.js
var React18 = __toESM(require_react(), 1);
var MenuRadioGroupContext = React18.createContext(void 0);
if (true) MenuRadioGroupContext.displayName = "MenuRadioGroupContext";
function useMenuRadioGroupContext() {
  const context = React18.useContext(MenuRadioGroupContext);
  if (context === void 0) {
    throw new Error(true ? "Base UI: MenuRadioGroupContext is missing. MenuRadioGroup parts must be placed within <Menu.RadioGroup>." : formatErrorMessage(34));
  }
  return context;
}

// node_modules/@base-ui/react/esm/menu/radio-group/MenuRadioGroup.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var MenuRadioGroup = React19.memo(React19.forwardRef(function MenuRadioGroup2(componentProps, forwardedRef) {
  const {
    render,
    className,
    value: valueProp,
    defaultValue,
    onValueChange: onValueChangeProp,
    disabled = false,
    ...elementProps
  } = componentProps;
  const [value, setValueUnwrapped] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "MenuRadioGroup"
  });
  const onValueChange = useStableCallback(onValueChangeProp);
  const setValue = useStableCallback((newValue, eventDetails) => {
    onValueChange?.(newValue, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    setValueUnwrapped(newValue);
  });
  const state = React19.useMemo(() => ({
    disabled
  }), [disabled]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    props: {
      role: "group",
      "aria-disabled": disabled || void 0,
      ...elementProps
    }
  });
  const context = React19.useMemo(() => ({
    value,
    setValue,
    disabled
  }), [value, setValue, disabled]);
  return (0, import_jsx_runtime6.jsx)(MenuRadioGroupContext.Provider, {
    value: context,
    children: element
  });
}));
if (true) MenuRadioGroup.displayName = "MenuRadioGroup";

// node_modules/@base-ui/react/esm/menu/radio-item/MenuRadioItem.js
var React21 = __toESM(require_react(), 1);

// node_modules/@base-ui/react/esm/menu/radio-item/MenuRadioItemContext.js
var React20 = __toESM(require_react(), 1);
var MenuRadioItemContext = React20.createContext(void 0);
if (true) MenuRadioItemContext.displayName = "MenuRadioItemContext";
function useMenuRadioItemContext() {
  const context = React20.useContext(MenuRadioItemContext);
  if (context === void 0) {
    throw new Error(true ? "Base UI: MenuRadioItemContext is missing. MenuRadioItem parts must be placed within <Menu.RadioItem>." : formatErrorMessage(35));
  }
  return context;
}

// node_modules/@base-ui/react/esm/menu/radio-item/MenuRadioItem.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var MenuRadioItem = React21.forwardRef(function MenuRadioItem2(componentProps, forwardedRef) {
  const {
    render,
    className,
    id: idProp,
    label,
    nativeButton = false,
    disabled: disabledProp = false,
    closeOnClick = false,
    value,
    ...elementProps
  } = componentProps;
  const listItem = useCompositeListItem({
    label
  });
  const menuPositionerContext = useMenuPositionerContext(true);
  const id = useBaseUiId(idProp);
  const {
    store
  } = useMenuRootContext();
  const highlighted = store.useState("isActive", listItem.index);
  const itemProps = store.useState("itemProps");
  const {
    value: selectedValue,
    setValue: setSelectedValue,
    disabled: groupDisabled
  } = useMenuRadioGroupContext();
  const disabled = groupDisabled || disabledProp;
  const checked = selectedValue === value;
  const {
    getItemProps,
    itemRef
  } = useMenuItem({
    closeOnClick,
    disabled,
    highlighted,
    id,
    store,
    nativeButton,
    nodeId: menuPositionerContext?.nodeId,
    itemMetadata: REGULAR_ITEM
  });
  const state = React21.useMemo(() => ({
    disabled,
    highlighted,
    checked
  }), [disabled, highlighted, checked]);
  const handleClick = useStableCallback((event) => {
    const details = {
      ...createChangeEventDetails(reason_parts_exports.itemPress, event.nativeEvent),
      preventUnmountOnClose: () => {
      }
    };
    setSelectedValue(value, details);
  });
  const element = useRenderElement("div", componentProps, {
    state,
    stateAttributesMapping: itemMapping,
    props: [itemProps, {
      role: "menuitemradio",
      "aria-checked": checked,
      onClick: handleClick
    }, elementProps, getItemProps],
    ref: [itemRef, forwardedRef, listItem.ref]
  });
  return (0, import_jsx_runtime7.jsx)(MenuRadioItemContext.Provider, {
    value: state,
    children: element
  });
});
if (true) MenuRadioItem.displayName = "MenuRadioItem";

// node_modules/@base-ui/react/esm/menu/radio-item-indicator/MenuRadioItemIndicator.js
var React22 = __toESM(require_react(), 1);
var MenuRadioItemIndicator = React22.forwardRef(function MenuRadioItemIndicator2(componentProps, forwardedRef) {
  const {
    render,
    className,
    keepMounted = false,
    ...elementProps
  } = componentProps;
  const item = useMenuRadioItemContext();
  const indicatorRef = React22.useRef(null);
  const {
    transitionStatus,
    setMounted
  } = useTransitionStatus(item.checked);
  useOpenChangeComplete({
    open: item.checked,
    ref: indicatorRef,
    onComplete() {
      if (!item.checked) {
        setMounted(false);
      }
    }
  });
  const state = React22.useMemo(() => ({
    checked: item.checked,
    disabled: item.disabled,
    highlighted: item.highlighted,
    transitionStatus
  }), [item.checked, item.disabled, item.highlighted, transitionStatus]);
  const element = useRenderElement("span", componentProps, {
    state,
    stateAttributesMapping: itemMapping,
    ref: [forwardedRef, indicatorRef],
    props: {
      "aria-hidden": true,
      ...elementProps
    },
    enabled: keepMounted || item.checked
  });
  return element;
});
if (true) MenuRadioItemIndicator.displayName = "MenuRadioItemIndicator";

// node_modules/@base-ui/react/esm/menu/root/MenuRoot.js
var React26 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// node_modules/@base-ui/react/esm/menubar/MenubarContext.js
var React23 = __toESM(require_react(), 1);
var MenubarContext = React23.createContext(null);
if (true) MenubarContext.displayName = "MenubarContext";
function useMenubarContext(optional) {
  const context = React23.useContext(MenubarContext);
  if (context === null && !optional) {
    throw new Error(true ? "Base UI: MenubarContext is missing. Menubar parts must be placed within <Menubar>." : formatErrorMessage(5));
  }
  return context;
}

// node_modules/@base-ui/react/esm/menu/store/MenuStore.js
var React24 = __toESM(require_react(), 1);
var selectors = {
  ...popupStoreSelectors,
  disabled: createSelector((state) => state.parent.type === "menubar" ? state.parent.context.disabled || state.disabled : state.disabled),
  modal: createSelector((state) => (state.parent.type === void 0 || state.parent.type === "context-menu") && (state.modal ?? true)),
  allowMouseEnter: createSelector((state) => state.parent.type === "menu" ? state.parent.store.select("allowMouseEnter") : state.allowMouseEnter),
  stickIfOpen: createSelector((state) => state.stickIfOpen),
  parent: createSelector((state) => state.parent),
  rootId: createSelector((state) => {
    if (state.parent.type === "menu") {
      return state.parent.store.select("rootId");
    }
    return state.parent.type !== void 0 ? state.parent.context.rootId : state.rootId;
  }),
  activeIndex: createSelector((state) => state.activeIndex),
  isActive: createSelector((state, itemIndex) => state.activeIndex === itemIndex),
  hoverEnabled: createSelector((state) => state.hoverEnabled),
  instantType: createSelector((state) => state.instantType),
  lastOpenChangeReason: createSelector((state) => state.openChangeReason),
  floatingTreeRoot: createSelector((state) => {
    if (state.parent.type === "menu") {
      return state.parent.store.select("floatingTreeRoot");
    }
    return state.floatingTreeRoot;
  }),
  floatingNodeId: createSelector((state) => state.floatingNodeId),
  floatingParentNodeId: createSelector((state) => state.floatingParentNodeId),
  itemProps: createSelector((state) => state.itemProps),
  closeDelay: createSelector((state) => state.closeDelay),
  keyboardEventRelay: createSelector((state) => {
    if (state.keyboardEventRelay) {
      return state.keyboardEventRelay;
    }
    if (state.parent.type === "menu") {
      return state.parent.store.select("keyboardEventRelay");
    }
    return void 0;
  })
};
var MenuStore = class _MenuStore extends ReactStore {
  constructor(initialState) {
    super({
      ...createInitialState(),
      ...initialState
    }, {
      positionerRef: React24.createRef(),
      popupRef: React24.createRef(),
      typingRef: {
        current: false
      },
      itemDomElements: {
        current: []
      },
      itemLabels: {
        current: []
      },
      allowMouseUpTriggerRef: {
        current: false
      },
      triggerFocusTargetRef: React24.createRef(),
      beforeContentFocusGuardRef: React24.createRef(),
      onOpenChangeComplete: void 0,
      triggerElements: new PopupTriggerMap()
    }, selectors);
    this.observe(createSelector((state) => state.allowMouseEnter), (allowMouseEnter, oldValue) => {
      if (this.state.parent.type === "menu" && allowMouseEnter !== oldValue) {
        this.state.parent.store.set("allowMouseEnter", allowMouseEnter);
      }
    });
    this.unsubscribeParentListener = this.observe("parent", (parent) => {
      this.unsubscribeParentListener?.();
      if (parent.type === "menu") {
        this.unsubscribeParentListener = parent.store.subscribe(() => {
          this.notifyAll();
        });
        this.context.allowMouseUpTriggerRef = parent.store.context.allowMouseUpTriggerRef;
        return;
      }
      if (parent.type !== void 0) {
        this.context.allowMouseUpTriggerRef = parent.context.allowMouseUpTriggerRef;
      }
      this.unsubscribeParentListener = null;
    });
  }
  setOpen(open, eventDetails) {
    this.state.floatingRootContext.context.events.emit("setOpen", {
      open,
      eventDetails
    });
  }
  static useStore(externalStore, initialState) {
    const internalStore = useRefWithInit(() => {
      return new _MenuStore(initialState);
    }).current;
    return externalStore ?? internalStore;
  }
  unsubscribeParentListener = null;
};
function createInitialState() {
  return {
    ...createInitialPopupStoreState(),
    disabled: false,
    modal: true,
    allowMouseEnter: true,
    stickIfOpen: true,
    parent: {
      type: void 0
    },
    rootId: void 0,
    activeIndex: null,
    hoverEnabled: true,
    instantType: void 0,
    openChangeReason: null,
    floatingTreeRoot: new FloatingTreeStore(),
    floatingNodeId: void 0,
    floatingParentNodeId: null,
    itemProps: EMPTY_OBJECT,
    keyboardEventRelay: void 0,
    closeDelay: 0
  };
}

// node_modules/@base-ui/react/esm/menu/submenu-root/MenuSubmenuRootContext.js
var React25 = __toESM(require_react(), 1);
var MenuSubmenuRootContext = React25.createContext(void 0);
if (true) MenuSubmenuRootContext.displayName = "MenuSubmenuRootContext";
function useMenuSubmenuRootContext() {
  return React25.useContext(MenuSubmenuRootContext);
}

// node_modules/@base-ui/react/esm/menu/root/MenuRoot.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
function MenuRoot(props) {
  const {
    children,
    open: openProp,
    onOpenChange,
    onOpenChangeComplete,
    defaultOpen = false,
    disabled: disabledProp = false,
    modal: modalProp,
    loopFocus = true,
    orientation = "vertical",
    actionsRef,
    closeParentOnEsc = false,
    handle,
    triggerId: triggerIdProp,
    defaultTriggerId: defaultTriggerIdProp = null,
    highlightItemOnHover = true
  } = props;
  const contextMenuContext = useContextMenuRootContext(true);
  const parentMenuRootContext = useMenuRootContext(true);
  const menubarContext = useMenubarContext(true);
  const isSubmenu = useMenuSubmenuRootContext();
  const parentFromContext = React26.useMemo(() => {
    if (isSubmenu && parentMenuRootContext) {
      return {
        type: "menu",
        store: parentMenuRootContext.store
      };
    }
    if (menubarContext) {
      return {
        type: "menubar",
        context: menubarContext
      };
    }
    if (contextMenuContext && !parentMenuRootContext) {
      return {
        type: "context-menu",
        context: contextMenuContext
      };
    }
    return {
      type: void 0
    };
  }, [contextMenuContext, parentMenuRootContext, menubarContext, isSubmenu]);
  const store = MenuStore.useStore(handle?.store, {
    parent: parentFromContext
  });
  const floatingTreeRoot = store.useState("floatingTreeRoot");
  const floatingNodeIdFromContext = useFloatingNodeId(floatingTreeRoot);
  const floatingParentNodeIdFromContext = useFloatingParentNodeId();
  useIsoLayoutEffect(() => {
    if (contextMenuContext && !parentMenuRootContext) {
      store.update({
        parent: {
          type: "context-menu",
          context: contextMenuContext
        },
        floatingNodeId: floatingNodeIdFromContext,
        floatingParentNodeId: floatingParentNodeIdFromContext
      });
    } else if (parentMenuRootContext) {
      store.update({
        floatingNodeId: floatingNodeIdFromContext,
        floatingParentNodeId: floatingParentNodeIdFromContext
      });
    }
  }, [contextMenuContext, parentMenuRootContext, floatingNodeIdFromContext, floatingParentNodeIdFromContext, store]);
  store.useControlledProp("open", openProp, defaultOpen);
  store.useControlledProp("activeTriggerId", triggerIdProp, defaultTriggerIdProp);
  store.useContextCallback("onOpenChangeComplete", onOpenChangeComplete);
  const open = store.useState("open");
  const activeTriggerElement = store.useState("activeTriggerElement");
  const positionerElement = store.useState("positionerElement");
  const hoverEnabled = store.useState("hoverEnabled");
  const modal = store.useState("modal");
  const disabled = store.useState("disabled");
  const lastOpenChangeReason = store.useState("lastOpenChangeReason");
  const parent = store.useState("parent");
  const activeIndex = store.useState("activeIndex");
  const payload = store.useState("payload");
  const floatingParentNodeId = store.useState("floatingParentNodeId");
  const openEventRef = React26.useRef(null);
  const nested = floatingParentNodeId != null;
  let floatingEvents;
  if (true) {
    if (parent.type !== void 0 && modalProp !== void 0) {
      console.warn("Base UI: The `modal` prop is not supported on nested menus. It will be ignored.");
    }
  }
  store.useSyncedValues({
    disabled: disabledProp,
    modal: parent.type === void 0 ? modalProp : void 0,
    rootId: useId()
  });
  const {
    openMethod,
    triggerProps: interactionTypeProps,
    reset: resetOpenInteractionType
  } = useOpenInteractionType(open);
  useImplicitActiveTrigger(store);
  const {
    forceUnmount
  } = useOpenStateTransitions(open, store, () => {
    store.update({
      allowMouseEnter: false,
      stickIfOpen: true
    });
    resetOpenInteractionType();
  });
  const allowOutsidePressDismissalRef = React26.useRef(parent.type !== "context-menu");
  const allowOutsidePressDismissalTimeout = useTimeout();
  React26.useEffect(() => {
    if (!open) {
      openEventRef.current = null;
    }
    if (parent.type !== "context-menu") {
      return;
    }
    if (!open) {
      allowOutsidePressDismissalTimeout.clear();
      allowOutsidePressDismissalRef.current = false;
      return;
    }
    allowOutsidePressDismissalTimeout.start(500, () => {
      allowOutsidePressDismissalRef.current = true;
    });
  }, [allowOutsidePressDismissalTimeout, open, parent.type]);
  useScrollLock(open && modal && lastOpenChangeReason !== reason_parts_exports.triggerHover && openMethod !== "touch", positionerElement);
  useIsoLayoutEffect(() => {
    if (!open && !hoverEnabled) {
      store.set("hoverEnabled", true);
    }
  }, [open, hoverEnabled, store]);
  const allowTouchToCloseRef = React26.useRef(true);
  const allowTouchToCloseTimeout = useTimeout();
  const setOpen = useStableCallback((nextOpen, eventDetails) => {
    const reason = eventDetails.reason;
    if (open === nextOpen && eventDetails.trigger === activeTriggerElement && lastOpenChangeReason === reason) {
      return;
    }
    eventDetails.preventUnmountOnClose = () => {
      store.set("preventUnmountingOnClose", true);
    };
    if (!nextOpen && eventDetails.trigger == null) {
      eventDetails.trigger = activeTriggerElement ?? void 0;
    }
    onOpenChange?.(nextOpen, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    const details = {
      open: nextOpen,
      nativeEvent: eventDetails.event,
      reason: eventDetails.reason,
      nested
    };
    floatingEvents?.emit("openchange", details);
    const nativeEvent = eventDetails.event;
    if (nextOpen === false && nativeEvent?.type === "click" && nativeEvent.pointerType === "touch" && !allowTouchToCloseRef.current) {
      return;
    }
    if (!nextOpen && activeIndex !== null) {
      const activeOption = store.context.itemDomElements.current[activeIndex];
      queueMicrotask(() => {
        activeOption?.setAttribute("tabindex", "-1");
      });
    }
    if (nextOpen && reason === reason_parts_exports.triggerFocus) {
      allowTouchToCloseRef.current = false;
      allowTouchToCloseTimeout.start(300, () => {
        allowTouchToCloseRef.current = true;
      });
    } else {
      allowTouchToCloseRef.current = true;
      allowTouchToCloseTimeout.clear();
    }
    const isKeyboardClick = (reason === reason_parts_exports.triggerPress || reason === reason_parts_exports.itemPress) && nativeEvent.detail === 0 && nativeEvent?.isTrusted;
    const isDismissClose = !nextOpen && (reason === reason_parts_exports.escapeKey || reason == null);
    function changeState() {
      const updatedState = {
        open: nextOpen,
        openChangeReason: reason
      };
      openEventRef.current = eventDetails.event ?? null;
      const newTriggerId = eventDetails.trigger?.id ?? null;
      if (newTriggerId || nextOpen) {
        updatedState.activeTriggerId = newTriggerId;
        updatedState.activeTriggerElement = eventDetails.trigger ?? null;
      }
      store.update(updatedState);
    }
    if (reason === reason_parts_exports.triggerHover) {
      ReactDOM.flushSync(changeState);
    } else {
      changeState();
    }
    if (parent.type === "menubar" && (reason === reason_parts_exports.triggerFocus || reason === reason_parts_exports.focusOut || reason === reason_parts_exports.triggerHover || reason === reason_parts_exports.listNavigation || reason === reason_parts_exports.siblingOpen)) {
      store.set("instantType", "group");
    } else if (isKeyboardClick || isDismissClose) {
      store.set("instantType", isKeyboardClick ? "click" : "dismiss");
    } else {
      store.set("instantType", void 0);
    }
  });
  const createMenuEventDetails = React26.useCallback((reason) => {
    const details = createChangeEventDetails(reason);
    details.preventUnmountOnClose = () => {
      store.set("preventUnmountingOnClose", true);
    };
    return details;
  }, [store]);
  const handleImperativeClose = React26.useCallback(() => {
    store.setOpen(false, createMenuEventDetails(reason_parts_exports.imperativeAction));
  }, [store, createMenuEventDetails]);
  React26.useImperativeHandle(actionsRef, () => ({
    unmount: forceUnmount,
    close: handleImperativeClose
  }), [forceUnmount, handleImperativeClose]);
  let ctx;
  if (parent.type === "context-menu") {
    ctx = parent.context;
  }
  React26.useImperativeHandle(ctx?.positionerRef, () => positionerElement, [positionerElement]);
  React26.useImperativeHandle(ctx?.actionsRef, () => ({
    setOpen
  }), [setOpen]);
  const floatingRootContext = useSyncedFloatingRootContext({
    popupStore: store,
    onOpenChange: setOpen
  });
  floatingEvents = floatingRootContext.context.events;
  React26.useEffect(() => {
    const handleSetOpenEvent = ({
      open: nextOpen,
      eventDetails
    }) => setOpen(nextOpen, eventDetails);
    floatingEvents.on("setOpen", handleSetOpenEvent);
    return () => {
      floatingEvents?.off("setOpen", handleSetOpenEvent);
    };
  }, [floatingEvents, setOpen]);
  const dismiss = useDismiss(floatingRootContext, {
    enabled: !disabled,
    bubbles: {
      escapeKey: closeParentOnEsc && parent.type === "menu"
    },
    outsidePress() {
      if (parent.type !== "context-menu" || openEventRef.current?.type === "contextmenu") {
        return true;
      }
      return allowOutsidePressDismissalRef.current;
    },
    externalTree: nested ? floatingTreeRoot : void 0
  });
  const role = useRole(floatingRootContext, {
    role: "menu"
  });
  const direction = useDirection();
  const setActiveIndex = React26.useCallback((index) => {
    if (store.select("activeIndex") === index) {
      return;
    }
    store.set("activeIndex", index);
  }, [store]);
  const listNavigation = useListNavigation(floatingRootContext, {
    enabled: !disabled,
    listRef: store.context.itemDomElements,
    activeIndex,
    nested: parent.type !== void 0,
    loopFocus,
    orientation,
    parentOrientation: parent.type === "menubar" ? parent.context.orientation : void 0,
    rtl: direction === "rtl",
    disabledIndices: EMPTY_ARRAY,
    onNavigate: setActiveIndex,
    openOnArrowKeyDown: parent.type !== "context-menu",
    externalTree: nested ? floatingTreeRoot : void 0,
    focusItemOnHover: highlightItemOnHover
  });
  const onTypingChange = React26.useCallback((nextTyping) => {
    store.context.typingRef.current = nextTyping;
  }, [store]);
  const typeahead = useTypeahead(floatingRootContext, {
    listRef: store.context.itemLabels,
    activeIndex,
    resetMs: TYPEAHEAD_RESET_MS,
    onMatch: (index) => {
      if (open && index !== activeIndex) {
        store.set("activeIndex", index);
      }
    },
    onTypingChange
  });
  const {
    getReferenceProps,
    getFloatingProps,
    getItemProps,
    getTriggerProps
  } = useInteractions([dismiss, role, listNavigation, typeahead]);
  const activeTriggerProps = React26.useMemo(() => {
    const mergedProps = mergeProps(getReferenceProps(), {
      onMouseEnter() {
        store.set("hoverEnabled", true);
      },
      onMouseMove() {
        store.set("allowMouseEnter", true);
      }
    }, interactionTypeProps);
    delete mergedProps.role;
    return mergedProps;
  }, [getReferenceProps, store, interactionTypeProps]);
  const inactiveTriggerProps = React26.useMemo(() => {
    const triggerProps = getTriggerProps();
    if (!triggerProps) {
      return triggerProps;
    }
    const mergedProps = mergeProps(triggerProps, interactionTypeProps);
    delete mergedProps.role;
    delete mergedProps["aria-controls"];
    return mergedProps;
  }, [getTriggerProps, interactionTypeProps]);
  const disableHoverTimeout = useAnimationFrame();
  const popupProps = React26.useMemo(() => getFloatingProps({
    onMouseEnter() {
      if (parent.type === "menu") {
        disableHoverTimeout.request(() => store.set("hoverEnabled", false));
      }
    },
    onMouseMove() {
      store.set("allowMouseEnter", true);
    },
    onClick() {
      if (store.select("hoverEnabled")) {
        store.set("hoverEnabled", false);
      }
    },
    onKeyDown(event) {
      const relay = store.select("keyboardEventRelay");
      if (relay && !event.isPropagationStopped()) {
        relay(event);
      }
    }
  }), [getFloatingProps, parent.type, disableHoverTimeout, store]);
  const itemProps = React26.useMemo(() => getItemProps(), [getItemProps]);
  store.useSyncedValues({
    floatingRootContext,
    activeTriggerProps,
    inactiveTriggerProps,
    popupProps,
    itemProps
  });
  const context = React26.useMemo(() => ({
    store,
    parent: parentFromContext
  }), [store, parentFromContext]);
  const content = (0, import_jsx_runtime8.jsx)(MenuRootContext.Provider, {
    value: context,
    children: typeof children === "function" ? children({
      payload
    }) : children
  });
  if (parent.type === void 0 || parent.type === "context-menu") {
    return (0, import_jsx_runtime8.jsx)(FloatingTree, {
      externalTree: floatingTreeRoot,
      children: content
    });
  }
  return content;
}

// node_modules/@base-ui/react/esm/menu/submenu-root/MenuSubmenuRoot.js
var React27 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
function MenuSubmenuRoot(props) {
  const parentMenu = useMenuRootContext().store;
  const contextValue = React27.useMemo(() => ({
    parentMenu
  }), [parentMenu]);
  return (0, import_jsx_runtime9.jsx)(MenuSubmenuRootContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime9.jsx)(MenuRoot, {
      ...props
    })
  });
}

// node_modules/@base-ui/react/esm/menu/trigger/MenuTrigger.js
var React30 = __toESM(require_react(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);

// node_modules/@base-ui/react/esm/composite/item/useCompositeItem.js
var React28 = __toESM(require_react(), 1);
function useCompositeItem(params = {}) {
  const {
    highlightItemOnHover,
    highlightedIndex,
    onHighlightedIndexChange
  } = useCompositeRootContext();
  const {
    ref,
    index
  } = useCompositeListItem(params);
  const isHighlighted = highlightedIndex === index;
  const itemRef = React28.useRef(null);
  const mergedRef = useMergedRefs(ref, itemRef);
  const compositeProps = React28.useMemo(() => ({
    tabIndex: isHighlighted ? 0 : -1,
    onFocus() {
      onHighlightedIndexChange(index);
    },
    onMouseMove() {
      const item = itemRef.current;
      if (!highlightItemOnHover || !item) {
        return;
      }
      const disabled = item.hasAttribute("disabled") || item.ariaDisabled === "true";
      if (!isHighlighted && !disabled) {
        item.focus();
      }
    }
  }), [isHighlighted, onHighlightedIndexChange, index, highlightItemOnHover]);
  return {
    compositeProps,
    compositeRef: mergedRef,
    index
  };
}

// node_modules/@base-ui/react/esm/composite/item/CompositeItem.js
function CompositeItem(componentProps) {
  const {
    render,
    className,
    state = EMPTY_OBJECT,
    props = EMPTY_ARRAY,
    refs = EMPTY_ARRAY,
    metadata,
    stateAttributesMapping: stateAttributesMapping3,
    tag = "div",
    ...elementProps
  } = componentProps;
  const {
    compositeProps,
    compositeRef
  } = useCompositeItem({
    metadata
  });
  return useRenderElement(tag, componentProps, {
    state,
    ref: [...refs, compositeRef],
    props: [compositeProps, ...props, elementProps],
    stateAttributesMapping: stateAttributesMapping3
  });
}

// node_modules/@base-ui/react/esm/menu/utils/findRootOwnerId.js
function findRootOwnerId(node) {
  if (isHTMLElement(node) && node.hasAttribute("data-rootownerid")) {
    return node.getAttribute("data-rootownerid") ?? void 0;
  }
  if (isLastTraversableNode(node)) {
    return void 0;
  }
  return findRootOwnerId(getParentNode(node));
}

// node_modules/@base-ui/react/esm/utils/useMixedToggleClickHandler.js
var React29 = __toESM(require_react(), 1);
function useMixedToggleClickHandler(params) {
  const {
    enabled = true,
    mouseDownAction,
    open
  } = params;
  const ignoreClickRef = React29.useRef(false);
  return React29.useMemo(() => {
    if (!enabled) {
      return EMPTY_OBJECT;
    }
    return {
      onMouseDown: (event) => {
        if (mouseDownAction === "open" && !open || mouseDownAction === "close" && open) {
          ignoreClickRef.current = true;
          ownerDocument(event.currentTarget).addEventListener("click", () => {
            ignoreClickRef.current = false;
          }, {
            once: true
          });
        }
      },
      onClick: (event) => {
        if (ignoreClickRef.current) {
          ignoreClickRef.current = false;
          event.preventBaseUIHandler();
        }
      }
    };
  }, [enabled, mouseDownAction, open]);
}

// node_modules/@base-ui/react/esm/menu/trigger/MenuTrigger.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var BOUNDARY_OFFSET = 2;
var MenuTrigger = React30.forwardRef(function MenuTrigger2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled: disabledProp = false,
    nativeButton = true,
    id: idProp,
    openOnHover: openOnHoverProp,
    delay = 100,
    closeDelay = 0,
    handle,
    payload,
    ...elementProps
  } = componentProps;
  const rootContext = useMenuRootContext(true);
  const store = handle?.store ?? rootContext?.store;
  if (!store) {
    throw new Error(true ? "Base UI: <Menu.Trigger> must be either used within a <Menu.Root> component or provided with a handle." : formatErrorMessage(85));
  }
  const thisTriggerId = useBaseUiId(idProp);
  const isTriggerActive = store.useState("isTriggerActive", thisTriggerId);
  const floatingRootContext = store.useState("floatingRootContext");
  const isOpenedByThisTrigger = store.useState("isOpenedByTrigger", thisTriggerId);
  const triggerElementRef = React30.useRef(null);
  const parent = useMenuParent();
  const compositeRootContext = useCompositeRootContext(true);
  const floatingTreeRootFromContext = useFloatingTree();
  const floatingTreeRoot = React30.useMemo(() => {
    return floatingTreeRootFromContext ?? new FloatingTreeStore();
  }, [floatingTreeRootFromContext]);
  const floatingNodeId = useFloatingNodeId(floatingTreeRoot);
  const floatingParentNodeId = useFloatingParentNodeId();
  const {
    registerTrigger,
    isMountedByThisTrigger
  } = useTriggerDataForwarding(thisTriggerId, triggerElementRef, store, {
    payload,
    closeDelay,
    parent,
    floatingTreeRoot,
    floatingNodeId,
    floatingParentNodeId,
    keyboardEventRelay: compositeRootContext?.relayKeyboardEvent
  });
  const isInMenubar = parent.type === "menubar";
  const rootDisabled = store.useState("disabled");
  const disabled = disabledProp || rootDisabled || isInMenubar && parent.context.disabled;
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  React30.useEffect(() => {
    if (!isOpenedByThisTrigger && parent.type === void 0) {
      store.context.allowMouseUpTriggerRef.current = false;
    }
  }, [store, isOpenedByThisTrigger, parent.type]);
  const triggerRef = React30.useRef(null);
  const allowMouseUpTriggerTimeout = useTimeout();
  const handleDocumentMouseUp = useStableCallback((mouseEvent) => {
    if (!triggerRef.current) {
      return;
    }
    allowMouseUpTriggerTimeout.clear();
    store.context.allowMouseUpTriggerRef.current = false;
    const mouseUpTarget = mouseEvent.target;
    if (contains(triggerRef.current, mouseUpTarget) || contains(store.select("positionerElement"), mouseUpTarget) || mouseUpTarget === triggerRef.current) {
      return;
    }
    if (mouseUpTarget != null && findRootOwnerId(mouseUpTarget) === store.select("rootId")) {
      return;
    }
    const bounds = getPseudoElementBounds(triggerRef.current);
    if (mouseEvent.clientX >= bounds.left - BOUNDARY_OFFSET && mouseEvent.clientX <= bounds.right + BOUNDARY_OFFSET && mouseEvent.clientY >= bounds.top - BOUNDARY_OFFSET && mouseEvent.clientY <= bounds.bottom + BOUNDARY_OFFSET) {
      return;
    }
    floatingTreeRoot.events.emit("close", {
      domEvent: mouseEvent,
      reason: reason_parts_exports.cancelOpen
    });
  });
  React30.useEffect(() => {
    if (isOpenedByThisTrigger && store.select("lastOpenChangeReason") === reason_parts_exports.triggerHover) {
      const doc = ownerDocument(triggerRef.current);
      doc.addEventListener("mouseup", handleDocumentMouseUp, {
        once: true
      });
    }
  }, [isOpenedByThisTrigger, handleDocumentMouseUp, store]);
  const parentMenubarHasSubmenuOpen = isInMenubar && parent.context.hasSubmenuOpen;
  const openOnHover = openOnHoverProp ?? parentMenubarHasSubmenuOpen;
  const hoverProps = useHoverReferenceInteraction(floatingRootContext, {
    enabled: openOnHover && !disabled && parent.type !== "context-menu" && (!isInMenubar || parentMenubarHasSubmenuOpen && !isMountedByThisTrigger),
    handleClose: safePolygon({
      blockPointerEvents: !isInMenubar
    }),
    mouseOnly: true,
    move: false,
    restMs: parent.type === void 0 ? delay : void 0,
    delay: {
      close: closeDelay
    },
    triggerElementRef,
    externalTree: floatingTreeRoot,
    isActiveTrigger: isTriggerActive
  });
  const stickIfOpen = useStickIfOpen(isOpenedByThisTrigger, store.select("lastOpenChangeReason"));
  const click = useClick(floatingRootContext, {
    enabled: !disabled && parent.type !== "context-menu",
    event: isOpenedByThisTrigger && isInMenubar ? "click" : "mousedown",
    toggle: true,
    ignoreMouse: false,
    stickIfOpen: parent.type === void 0 ? stickIfOpen : false
  });
  const focus = useFocus(floatingRootContext, {
    enabled: !disabled && parentMenubarHasSubmenuOpen
  });
  const mixedToggleHandlers = useMixedToggleClickHandler({
    open: isOpenedByThisTrigger,
    enabled: isInMenubar,
    mouseDownAction: "open"
  });
  const localInteractionProps = useInteractions([click, focus]);
  const state = React30.useMemo(() => ({
    disabled,
    open: isOpenedByThisTrigger
  }), [disabled, isOpenedByThisTrigger]);
  const rootTriggerProps = store.useState("triggerProps", isMountedByThisTrigger);
  const ref = [triggerRef, forwardedRef, buttonRef, registerTrigger, triggerElementRef];
  const props = [localInteractionProps.getReferenceProps(), hoverProps ?? EMPTY_OBJECT, rootTriggerProps, {
    "aria-haspopup": "menu",
    id: thisTriggerId,
    onMouseDown: (event) => {
      if (store.select("open")) {
        return;
      }
      allowMouseUpTriggerTimeout.start(200, () => {
        store.context.allowMouseUpTriggerRef.current = true;
      });
      const doc = ownerDocument(event.currentTarget);
      doc.addEventListener("mouseup", handleDocumentMouseUp, {
        once: true
      });
    }
  }, isInMenubar ? {
    role: "menuitem"
  } : {}, mixedToggleHandlers, elementProps, getButtonProps];
  const preFocusGuardRef = React30.useRef(null);
  const handlePreFocusGuardFocus = useStableCallback((event) => {
    ReactDOM2.flushSync(() => {
      store.setOpen(false, createChangeEventDetails(reason_parts_exports.focusOut, event.nativeEvent, event.currentTarget));
    });
    const previousTabbable = getTabbableBeforeElement(preFocusGuardRef.current);
    previousTabbable?.focus();
  });
  const handleFocusTargetFocus = useStableCallback((event) => {
    const currentPositionerElement = store.select("positionerElement");
    if (currentPositionerElement && isOutsideEvent(event, currentPositionerElement)) {
      store.context.beforeContentFocusGuardRef.current?.focus();
    } else {
      ReactDOM2.flushSync(() => {
        store.setOpen(false, createChangeEventDetails(reason_parts_exports.focusOut, event.nativeEvent, event.currentTarget));
      });
      let nextTabbable = getTabbableAfterElement(store.context.triggerFocusTargetRef.current || triggerElementRef.current);
      while (nextTabbable !== null && contains(currentPositionerElement, nextTabbable)) {
        const prevTabbable = nextTabbable;
        nextTabbable = getNextTabbable(nextTabbable);
        if (nextTabbable === prevTabbable) {
          break;
        }
      }
      nextTabbable?.focus();
    }
  });
  const element = useRenderElement("button", componentProps, {
    enabled: !isInMenubar,
    stateAttributesMapping: pressableTriggerOpenStateMapping,
    state,
    ref,
    props
  });
  if (isInMenubar) {
    return (0, import_jsx_runtime10.jsx)(CompositeItem, {
      tag: "button",
      render,
      className,
      state,
      refs: ref,
      props,
      stateAttributesMapping: pressableTriggerOpenStateMapping
    });
  }
  if (isOpenedByThisTrigger) {
    return (0, import_jsx_runtime10.jsxs)(React30.Fragment, {
      children: [(0, import_jsx_runtime10.jsx)(FocusGuard, {
        ref: preFocusGuardRef,
        onFocus: handlePreFocusGuardFocus
      }, `${thisTriggerId}-pre-focus-guard`), (0, import_jsx_runtime10.jsx)(React30.Fragment, {
        children: element
      }, thisTriggerId), (0, import_jsx_runtime10.jsx)(FocusGuard, {
        ref: store.context.triggerFocusTargetRef,
        onFocus: handleFocusTargetFocus
      }, `${thisTriggerId}-post-focus-guard`)]
    });
  }
  return (0, import_jsx_runtime10.jsx)(React30.Fragment, {
    children: element
  }, thisTriggerId);
});
if (true) MenuTrigger.displayName = "MenuTrigger";
function useStickIfOpen(open, openReason) {
  const stickIfOpenTimeout = useTimeout();
  const [stickIfOpen, setStickIfOpen] = React30.useState(false);
  useIsoLayoutEffect(() => {
    if (open && openReason === "trigger-hover") {
      setStickIfOpen(true);
      stickIfOpenTimeout.start(PATIENT_CLICK_THRESHOLD, () => {
        setStickIfOpen(false);
      });
    } else if (!open) {
      stickIfOpenTimeout.clear();
      setStickIfOpen(false);
    }
  }, [open, openReason, stickIfOpenTimeout]);
  return stickIfOpen;
}
function useMenuParent() {
  const contextMenuContext = useContextMenuRootContext(true);
  const parentContext = useMenuRootContext(true);
  const menubarContext = useMenubarContext(true);
  const parent = React30.useMemo(() => {
    if (menubarContext) {
      return {
        type: "menubar",
        context: menubarContext
      };
    }
    if (contextMenuContext && !parentContext) {
      return {
        type: "context-menu",
        context: contextMenuContext
      };
    }
    return {
      type: void 0
    };
  }, [contextMenuContext, parentContext, menubarContext]);
  return parent;
}

// node_modules/@base-ui/react/esm/menu/submenu-trigger/MenuSubmenuTrigger.js
var React31 = __toESM(require_react(), 1);
var MenuSubmenuTrigger = React31.forwardRef(function SubmenuTriggerComponent(componentProps, forwardedRef) {
  const {
    render,
    className,
    label,
    id: idProp,
    nativeButton = false,
    openOnHover = true,
    delay = 100,
    closeDelay = 0,
    disabled: disabledProp = false,
    ...elementProps
  } = componentProps;
  const listItem = useCompositeListItem();
  const menuPositionerContext = useMenuPositionerContext();
  const {
    store
  } = useMenuRootContext();
  const thisTriggerId = useBaseUiId(idProp);
  const open = store.useState("open");
  const floatingRootContext = store.useState("floatingRootContext");
  const floatingTreeRoot = store.useState("floatingTreeRoot");
  const baseRegisterTrigger = useTriggerRegistration(thisTriggerId, store);
  const registerTrigger = React31.useCallback((element2) => {
    const cleanup = baseRegisterTrigger(element2);
    if (element2 !== null && store.select("open") && store.select("activeTriggerId") == null) {
      store.update({
        activeTriggerId: thisTriggerId,
        activeTriggerElement: element2,
        closeDelay
      });
    }
    return cleanup;
  }, [baseRegisterTrigger, closeDelay, store, thisTriggerId]);
  const triggerElementRef = React31.useRef(null);
  const handleTriggerElementRef = React31.useCallback((el) => {
    triggerElementRef.current = el;
    store.set("activeTriggerElement", el);
  }, [store]);
  const submenuRootContext = useMenuSubmenuRootContext();
  if (!submenuRootContext?.parentMenu) {
    throw new Error(true ? "Base UI: <Menu.SubmenuTrigger> must be placed in <Menu.SubmenuRoot>." : formatErrorMessage(37));
  }
  store.useSyncedValue("closeDelay", closeDelay);
  const parentMenuStore = submenuRootContext.parentMenu;
  const itemProps = parentMenuStore.useState("itemProps");
  const highlighted = parentMenuStore.useState("isActive", listItem.index);
  const itemMetadata = React31.useMemo(() => ({
    type: "submenu-trigger",
    setActive: () => parentMenuStore.set("activeIndex", listItem.index)
  }), [parentMenuStore, listItem.index]);
  const rootDisabled = store.useState("disabled");
  const disabled = disabledProp || rootDisabled;
  const {
    getItemProps,
    itemRef
  } = useMenuItem({
    closeOnClick: false,
    disabled,
    highlighted,
    id: thisTriggerId,
    store,
    nativeButton,
    itemMetadata,
    nodeId: menuPositionerContext?.nodeId
  });
  const hoverEnabled = store.useState("hoverEnabled");
  const allowMouseEnter = store.useState("allowMouseEnter");
  const hoverProps = useHoverReferenceInteraction(floatingRootContext, {
    enabled: hoverEnabled && openOnHover && !disabled && allowMouseEnter,
    handleClose: safePolygon({
      blockPointerEvents: true
    }),
    mouseOnly: true,
    move: true,
    restMs: delay,
    delay: {
      open: delay,
      close: closeDelay
    },
    triggerElementRef,
    externalTree: floatingTreeRoot
  });
  const click = useClick(floatingRootContext, {
    enabled: !disabled,
    event: "mousedown",
    toggle: !openOnHover,
    ignoreMouse: openOnHover,
    stickIfOpen: false
  });
  const localInteractionProps = useInteractions([click]);
  const rootTriggerProps = store.useState("triggerProps", true);
  delete rootTriggerProps.id;
  const state = React31.useMemo(() => ({
    disabled,
    highlighted,
    open
  }), [disabled, highlighted, open]);
  const element = useRenderElement("div", componentProps, {
    state,
    stateAttributesMapping: triggerOpenStateMapping,
    props: [localInteractionProps.getReferenceProps(), hoverProps, rootTriggerProps, itemProps, {
      tabIndex: open || highlighted ? 0 : -1,
      onBlur() {
        if (highlighted) {
          parentMenuStore.set("activeIndex", null);
        }
      }
    }, elementProps, getItemProps],
    ref: [forwardedRef, listItem.ref, itemRef, registerTrigger, handleTriggerElementRef]
  });
  return element;
});
if (true) MenuSubmenuTrigger.displayName = "MenuSubmenuTrigger";

// node_modules/@base-ui/react/esm/menu/store/MenuHandle.js
var MenuHandle = class {
  /**
   * Internal store holding the menu's state.
   * @internal
   */
  constructor() {
    this.store = new MenuStore();
  }
  /**
   * Opens the menu and associates it with the trigger with the given id.
   * The trigger must be a Menu.Trigger component with this handle passed as a prop.
   *
   * @param triggerId ID of the trigger to associate with the menu.
   */
  open(triggerId) {
    const triggerElement = triggerId ? this.store.context.triggerElements.getById(triggerId) : void 0;
    if (triggerId && !triggerElement) {
      throw new Error(true ? `Base UI: MenuHandle.open: No trigger found with id "${triggerId}".` : formatErrorMessage(83, triggerId));
    }
    this.store.setOpen(true, createChangeEventDetails("imperative-action", void 0, triggerElement));
  }
  /**
   * Closes the menu.
   */
  close() {
    this.store.setOpen(false, createChangeEventDetails("imperative-action", void 0, void 0));
  }
  /**
   * Indicates whether the menu is currently open.
   */
  get isOpen() {
    return this.store.state.open;
  }
};
function createMenuHandle() {
  return new MenuHandle();
}

export {
  ContextMenuRootContext,
  useContextMenuRootContext,
  MenuRootContext,
  useMenuRootContext,
  MenuArrow,
  MenuBackdrop,
  MenuCheckboxItem,
  MenuCheckboxItemIndicator,
  MenuGroup,
  MenuGroupLabel,
  MenuItem,
  MenuPopup,
  MenuPortal,
  MenuPositioner,
  MenuRadioGroup,
  MenuRadioItem,
  MenuRadioItemIndicator,
  MenubarContext,
  useMenubarContext,
  MenuSubmenuRoot,
  useCompositeItem,
  CompositeItem,
  findRootOwnerId,
  MenuSubmenuTrigger,
  index_parts_exports
};
//# sourceMappingURL=chunk-76EPQKOQ.js.map
