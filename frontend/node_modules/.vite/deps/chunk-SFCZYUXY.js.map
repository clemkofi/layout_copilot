{
  "version": 3,
  "sources": ["../../@base-ui/utils/esm/useId.js", "../../@base-ui/utils/esm/safeReact.js", "../../@base-ui/react/esm/utils/useBaseUiId.js", "../../@base-ui/utils/esm/detectBrowser.js", "../../@base-ui/react/esm/floating-ui-react/utils/constants.js", "../../@base-ui/react/esm/floating-ui-react/utils/element.js", "../../@base-ui/react/esm/floating-ui-react/utils/nodes.js", "../../@base-ui/react/esm/floating-ui-react/utils/event.js", "../../@floating-ui/utils/dist/floating-ui.utils.mjs", "../../@base-ui/react/esm/floating-ui-react/utils/composite.js", "../../tabbable/src/index.js", "../../@base-ui/react/esm/floating-ui-react/utils/tabbable.js", "../../@base-ui/react/esm/utils/reason-parts.js", "../../@base-ui/react/esm/utils/createBaseUIEventDetails.js", "../../@base-ui/utils/esm/useOnMount.js", "../../@base-ui/utils/esm/useTimeout.js", "../../@base-ui/utils/esm/owner.js"],
  "sourcesContent": ["'use client';\n\nimport * as React from 'react';\nimport { SafeReact } from \"./safeReact.js\";\nlet globalId = 0;\n\n// TODO React 17: Remove `useGlobalId` once React 17 support is removed\nfunction useGlobalId(idOverride, prefix = 'mui') {\n  const [defaultId, setDefaultId] = React.useState(idOverride);\n  const id = idOverride || defaultId;\n  React.useEffect(() => {\n    if (defaultId == null) {\n      // Fallback to this default id when possible.\n      // Use the incrementing value for client-side rendering only.\n      // We can't use it server-side.\n      // If you want to use random values please consider the Birthday Problem: https://en.wikipedia.org/wiki/Birthday_problem\n      globalId += 1;\n      setDefaultId(`${prefix}-${globalId}`);\n    }\n  }, [defaultId, prefix]);\n  return id;\n}\nconst maybeReactUseId = SafeReact.useId;\n\n/**\n *\n * @example <div id={useId()} />\n * @param idOverride\n * @returns {string}\n */\nexport function useId(idOverride, prefix) {\n  // React.useId() is only available from React 17.0.0.\n  if (maybeReactUseId !== undefined) {\n    const reactId = maybeReactUseId();\n    return idOverride ?? (prefix ? `${prefix}-${reactId}` : reactId);\n  }\n\n  // TODO: uncomment once we enable eslint-plugin-react-compiler // eslint-disable-next-line react-compiler/react-compiler\n  // eslint-disable-next-line react-hooks/rules-of-hooks -- `React.useId` is invariant at runtime.\n  return useGlobalId(idOverride, prefix);\n}", "import * as React from 'react';\n\n// https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379\nexport const SafeReact = {\n  ...React\n};", "'use client';\n\nimport { useId } from '@base-ui/utils/useId';\n\n/**\n * Wraps `useId` and prefixes generated `id`s with `base-ui-`\n * @param {string | undefined} idOverride overrides the generated id when provided\n * @returns {string | undefined}\n */\nexport function useBaseUiId(idOverride) {\n  return useId(idOverride, 'base-ui');\n}", "const hasNavigator = typeof navigator !== 'undefined';\nconst nav = getNavigatorData();\nconst platform = getPlatform();\nconst userAgent = getUserAgent();\nexport const isWebKit = typeof CSS === 'undefined' || !CSS.supports ? false : CSS.supports('-webkit-backdrop-filter:none');\nexport const isIOS =\n// iPads can claim to be MacIntel\nnav.platform === 'MacIntel' && nav.maxTouchPoints > 1 ? true : /iP(hone|ad|od)|iOS/.test(nav.platform);\nexport const isFirefox = hasNavigator && /firefox/i.test(userAgent);\nexport const isSafari = hasNavigator && /apple/i.test(navigator.vendor);\nexport const isEdge = hasNavigator && /Edg/i.test(userAgent);\nexport const isAndroid = hasNavigator && /android/i.test(platform) || /android/i.test(userAgent);\nexport const isMac = hasNavigator && platform.toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\nexport const isJSDOM = userAgent.includes('jsdom/');\n\n// Avoid Chrome DevTools blue warning.\nfunction getNavigatorData() {\n  if (!hasNavigator) {\n    return {\n      platform: '',\n      maxTouchPoints: -1\n    };\n  }\n  const uaData = navigator.userAgentData;\n  if (uaData?.platform) {\n    return {\n      platform: uaData.platform,\n      maxTouchPoints: navigator.maxTouchPoints\n    };\n  }\n  return {\n    platform: navigator.platform ?? '',\n    maxTouchPoints: navigator.maxTouchPoints ?? -1\n  };\n}\nfunction getUserAgent() {\n  if (!hasNavigator) {\n    return '';\n  }\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(({\n      brand,\n      version\n    }) => `${brand}/${version}`).join(' ');\n  }\n  return navigator.userAgent;\n}\nfunction getPlatform() {\n  if (!hasNavigator) {\n    return '';\n  }\n  const uaData = navigator.userAgentData;\n  if (uaData?.platform) {\n    return uaData.platform;\n  }\n  return navigator.platform ?? '';\n}", "export const FOCUSABLE_ATTRIBUTE = 'data-base-ui-focusable';\nexport const ACTIVE_KEY = 'active';\nexport const SELECTED_KEY = 'selected';\nexport const TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nexport const ARROW_LEFT = 'ArrowLeft';\nexport const ARROW_RIGHT = 'ArrowRight';\nexport const ARROW_UP = 'ArrowUp';\nexport const ARROW_DOWN = 'ArrowDown';", "import { isHTMLElement, isShadowRoot } from '@floating-ui/utils/dom';\nimport { isJSDOM } from '@base-ui/utils/detectBrowser';\nimport { FOCUSABLE_ATTRIBUTE, TYPEABLE_SELECTOR } from \"./constants.js\";\nexport function activeElement(doc) {\n  let element = doc.activeElement;\n  while (element?.shadowRoot?.activeElement != null) {\n    element = element.shadowRoot.activeElement;\n  }\n  return element;\n}\nexport function contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode?.();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n\n  // then fallback to custom implementation with Shadow DOM support\n  if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) {\n        return true;\n      }\n      next = next.parentNode || next.host;\n    }\n  }\n\n  // Give up, the result is false\n  return false;\n}\nexport function getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\nexport function isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n  const eventAgain = event;\n  return eventAgain.target != null && node.contains(eventAgain.target);\n}\nexport function isRootElement(element) {\n  return element.matches('html,body');\n}\nexport function getDocument(node) {\n  return node?.ownerDocument || document;\n}\nexport function isTypeableElement(element) {\n  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\nexport function isTypeableCombobox(element) {\n  if (!element) {\n    return false;\n  }\n  return element.getAttribute('role') === 'combobox' && isTypeableElement(element);\n}\nexport function matchesFocusVisible(element) {\n  // We don't want to block focus from working with `visibleOnly`\n  // (JSDOM doesn't match `:focus-visible` when the element has `:focus`)\n  if (!element || isJSDOM) {\n    return true;\n  }\n  try {\n    return element.matches(':focus-visible');\n  } catch (_e) {\n    return true;\n  }\n}\nexport function getFloatingFocusElement(floatingElement) {\n  if (!floatingElement) {\n    return null;\n  }\n  // Try to find the element that has `{...getFloatingProps()}` spread on it.\n  // This indicates the floating element is acting as a positioning wrapper, and\n  // so focus should be managed on the child element with the event handlers and\n  // aria props.\n  return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector(`[${FOCUSABLE_ATTRIBUTE}]`) || floatingElement;\n}", "/* eslint-disable @typescript-eslint/no-loop-func */\n\nexport function getNodeChildren(nodes, id, onlyOpenChildren = true) {\n  const directChildren = nodes.filter(node => node.parentId === id && (!onlyOpenChildren || node.context?.open));\n  return directChildren.flatMap(child => [child, ...getNodeChildren(nodes, child.id, onlyOpenChildren)]);\n}\nexport function getDeepestNode(nodes, id) {\n  let deepestNodeId;\n  let maxDepth = -1;\n  function findDeepest(nodeId, depth) {\n    if (depth > maxDepth) {\n      deepestNodeId = nodeId;\n      maxDepth = depth;\n    }\n    const children = getNodeChildren(nodes, nodeId);\n    children.forEach(child => {\n      findDeepest(child.id, depth + 1);\n    });\n  }\n  findDeepest(id, 0);\n  return nodes.find(node => node.id === deepestNodeId);\n}\nexport function getNodeAncestors(nodes, id) {\n  let allAncestors = [];\n  let currentParentId = nodes.find(node => node.id === id)?.parentId;\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode?.parentId;\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n  return allAncestors;\n}", "import { isAndroid, isJSDOM } from '@base-ui/utils/detectBrowser';\nexport function stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\nexport function isReactEvent(event) {\n  return 'nativeEvent' in event;\n}\n\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nexport function isVirtualClick(event) {\n  // FIXME: Firefox is now emitting a deprecation warning for `mozInputSource`.\n  // Try to find a workaround for this. `react-aria` source still has the check.\n  if (event.mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n  if (isAndroid && event.pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n  return event.detail === 0 && !event.pointerType;\n}\nexport function isVirtualPointerEvent(event) {\n  if (isJSDOM) {\n    return false;\n  }\n  return !isAndroid && event.width === 0 && event.height === 0 || isAndroid && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'mouse' ||\n  // iOS VoiceOver returns 0.333â€¢ for width/height.\n  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'touch';\n}\nexport function isMouseLikePointerType(pointerType, strict) {\n  // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n  // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n  const values = ['mouse', 'pen'];\n  if (!strict) {\n    values.push('', undefined);\n  }\n  return values.includes(pointerType);\n}\nexport function isClickLikeEvent(event) {\n  const type = event.type;\n  return type === 'click' || type === 'mousedown' || type === 'keydown' || type === 'keyup';\n}", "/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n", "import _formatErrorMessage from \"@base-ui/utils/formatErrorMessage\";\nimport { floor } from '@floating-ui/utils';\nimport { stopEvent } from \"./event.js\";\nimport { ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT, ARROW_UP } from \"./constants.js\";\nexport function isDifferentGridRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nexport function isIndexOutOfListBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nexport function getMinListIndex(listRef, disabledIndices) {\n  return findNonDisabledListIndex(listRef, {\n    disabledIndices\n  });\n}\nexport function getMaxListIndex(listRef, disabledIndices) {\n  return findNonDisabledListIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\nexport function findNonDisabledListIndex(listRef, {\n  startingIndex = -1,\n  decrement = false,\n  disabledIndices,\n  amount = 1\n} = {}) {\n  let index = startingIndex;\n  do {\n    index += decrement ? -amount : amount;\n  } while (index >= 0 && index <= listRef.current.length - 1 && isListIndexDisabled(listRef, index, disabledIndices));\n  return index;\n}\nexport function getGridNavigatedIndex(listRef, {\n  event,\n  orientation,\n  loopFocus,\n  rtl,\n  cols,\n  disabledIndices,\n  minIndex,\n  maxIndex,\n  prevIndex,\n  stopEvent: stop = false\n}) {\n  let nextIndex = prevIndex;\n\n  // ---------------------------------------------------------------------------\n  // Detect row structure based on DOM. This works when items are grouped inside\n  // elements that declare `role=\"row\"` (e.g., Combobox.Row). We build a matrix\n  // where each entry is the array of item indices for that visual row. The\n  // algorithm gracefully falls back to regular `cols`-based handling when no\n  // row structure can be detected.\n  // ---------------------------------------------------------------------------\n  const rows = [];\n  const rowIndexMap = {};\n  let hasRoleRow = false;\n  {\n    let currentRowEl = null;\n    let currentRowIndex = -1;\n    listRef.current.forEach((el, idx) => {\n      if (el == null) {\n        return;\n      }\n      const rowEl = el.closest('[role=\"row\"]');\n      if (rowEl) {\n        hasRoleRow = true;\n      }\n      if (rowEl !== currentRowEl || currentRowIndex === -1) {\n        currentRowEl = rowEl;\n        currentRowIndex += 1;\n        rows[currentRowIndex] = [];\n      }\n      rows[currentRowIndex].push(idx);\n      rowIndexMap[idx] = currentRowIndex;\n    });\n  }\n  const hasDomRows = hasRoleRow && rows.length > 0 && rows.some(row => row.length !== cols);\n  function navigateVertically(direction) {\n    if (!hasDomRows || prevIndex === -1) {\n      return undefined;\n    }\n    const currentRow = rowIndexMap[prevIndex];\n    if (currentRow == null) {\n      return undefined;\n    }\n    const colInRow = rows[currentRow].indexOf(prevIndex);\n    let nextRow = direction === 'up' ? currentRow - 1 : currentRow + 1;\n    if (loopFocus) {\n      if (nextRow < 0) {\n        nextRow = rows.length - 1;\n      } else if (nextRow >= rows.length) {\n        nextRow = 0;\n      }\n    }\n    const visited = new Set();\n    while (nextRow >= 0 && nextRow < rows.length && !visited.has(nextRow)) {\n      visited.add(nextRow);\n      const targetRow = rows[nextRow];\n      if (targetRow.length === 0) {\n        nextRow = direction === 'up' ? nextRow - 1 : nextRow + 1;\n        continue;\n      }\n      const clampedCol = Math.min(colInRow, targetRow.length - 1);\n      // Start from the preferred column, fallback leftwards until first\n      // enabled item is found.\n      for (let col = clampedCol; col >= 0; col -= 1) {\n        const candidate = targetRow[col];\n        if (!isListIndexDisabled(listRef, candidate, disabledIndices)) {\n          return candidate;\n        }\n      }\n      // Row had no enabled items, move to next row in the same direction.\n      nextRow = direction === 'up' ? nextRow - 1 : nextRow + 1;\n      if (loopFocus) {\n        if (nextRow < 0) {\n          nextRow = rows.length - 1;\n        } else if (nextRow >= rows.length) {\n          nextRow = 0;\n        }\n      }\n    }\n    return undefined;\n  }\n  if (event.key === ARROW_UP) {\n    const domBasedCandidate = navigateVertically('up');\n    if (domBasedCandidate !== undefined) {\n      if (stop) {\n        stopEvent(event);\n      }\n      nextIndex = domBasedCandidate;\n    } else {\n      // fallback to original logic\n      if (stop) {\n        stopEvent(event);\n      }\n      if (prevIndex === -1) {\n        nextIndex = maxIndex;\n      } else {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: nextIndex,\n          amount: cols,\n          decrement: true,\n          disabledIndices\n        });\n        if (loopFocus && (prevIndex - cols < minIndex || nextIndex < 0)) {\n          const col = prevIndex % cols;\n          const maxCol = maxIndex % cols;\n          const offset = maxIndex - (maxCol - col);\n          if (maxCol === col) {\n            nextIndex = maxIndex;\n          } else {\n            nextIndex = maxCol > col ? offset : offset - cols;\n          }\n        }\n      }\n      if (isIndexOutOfListBounds(listRef, nextIndex)) {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n  if (event.key === ARROW_DOWN) {\n    const domBasedCandidate = navigateVertically('down');\n    if (domBasedCandidate !== undefined) {\n      if (stop) {\n        stopEvent(event);\n      }\n      nextIndex = domBasedCandidate;\n    } else {\n      if (stop) {\n        stopEvent(event);\n      }\n      if (prevIndex === -1) {\n        nextIndex = minIndex;\n      } else {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex,\n          amount: cols,\n          disabledIndices\n        });\n        if (loopFocus && prevIndex + cols > maxIndex) {\n          nextIndex = findNonDisabledListIndex(listRef, {\n            startingIndex: prevIndex % cols - cols,\n            amount: cols,\n            disabledIndices\n          });\n        }\n      }\n      if (isIndexOutOfListBounds(listRef, nextIndex)) {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n\n  // Remains on the same row/column.\n  if (orientation === 'both') {\n    const prevRow = floor(prevIndex / cols);\n    if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {\n      if (stop) {\n        stopEvent(event);\n      }\n      if (prevIndex % cols !== cols - 1) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex,\n          disabledIndices\n        });\n        if (loopFocus && isDifferentGridRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledListIndex(listRef, {\n            startingIndex: prevIndex - prevIndex % cols - 1,\n            disabledIndices\n          });\n        }\n      } else if (loopFocus) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      }\n      if (isDifferentGridRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {\n      if (stop) {\n        stopEvent(event);\n      }\n      if (prevIndex % cols !== 0) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex,\n          decrement: true,\n          disabledIndices\n        });\n        if (loopFocus && isDifferentGridRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledListIndex(listRef, {\n            startingIndex: prevIndex + (cols - prevIndex % cols),\n            decrement: true,\n            disabledIndices\n          });\n        }\n      } else if (loopFocus) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex + (cols - prevIndex % cols),\n          decrement: true,\n          disabledIndices\n        });\n      }\n      if (isDifferentGridRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    const lastRow = floor(maxIndex / cols) === prevRow;\n    if (isIndexOutOfListBounds(listRef, nextIndex)) {\n      if (loopFocus && lastRow) {\n        nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      } else {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n  return nextIndex;\n}\n\n/** For each cell index, gets the item index that occupies that cell */\nexport function createGridCellMap(sizes, cols, dense) {\n  const cellMap = [];\n  let startIndex = 0;\n  sizes.forEach(({\n    width,\n    height\n  }, index) => {\n    if (width > cols) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(process.env.NODE_ENV !== \"production\" ? `[Floating UI]: Invalid grid - item width at index ${index} is greater than grid columns` : _formatErrorMessage(29, index));\n      }\n    }\n    let itemPlaced = false;\n    if (dense) {\n      startIndex = 0;\n    }\n    while (!itemPlaced) {\n      const targetCells = [];\n      for (let i = 0; i < width; i += 1) {\n        for (let j = 0; j < height; j += 1) {\n          targetCells.push(startIndex + i + j * cols);\n        }\n      }\n      if (startIndex % cols + width <= cols && targetCells.every(cell => cellMap[cell] == null)) {\n        targetCells.forEach(cell => {\n          cellMap[cell] = index;\n        });\n        itemPlaced = true;\n      } else {\n        startIndex += 1;\n      }\n    }\n  });\n\n  // convert into a non-sparse array\n  return [...cellMap];\n}\n\n/** Gets cell index of an item's corner or -1 when index is -1. */\nexport function getGridCellIndexOfCorner(index, sizes, cellMap, cols, corner) {\n  if (index === -1) {\n    return -1;\n  }\n  const firstCellIndex = cellMap.indexOf(index);\n  const sizeItem = sizes[index];\n  switch (corner) {\n    case 'tl':\n      return firstCellIndex;\n    case 'tr':\n      if (!sizeItem) {\n        return firstCellIndex;\n      }\n      return firstCellIndex + sizeItem.width - 1;\n    case 'bl':\n      if (!sizeItem) {\n        return firstCellIndex;\n      }\n      return firstCellIndex + (sizeItem.height - 1) * cols;\n    case 'br':\n      return cellMap.lastIndexOf(index);\n    default:\n      return -1;\n  }\n}\n\n/** Gets all cell indices that correspond to the specified indices */\nexport function getGridCellIndices(indices, cellMap) {\n  return cellMap.flatMap((index, cellIndex) => indices.includes(index) ? [cellIndex] : []);\n}\nexport function isListIndexDisabled(listRef, index, disabledIndices) {\n  if (typeof disabledIndices === 'function') {\n    return disabledIndices(index);\n  }\n  if (disabledIndices) {\n    return disabledIndices.includes(index);\n  }\n  const element = listRef.current[index];\n  if (!element) {\n    return false;\n  }\n  return element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';\n}", "// NOTE: separate `:not()` selectors has broader browser support than the newer\n//  `:not([inert], [inert] *)` (Feb 2023)\nconst candidateSelectors = [\n  'input:not([inert]):not([inert] *)',\n  'select:not([inert]):not([inert] *)',\n  'textarea:not([inert]):not([inert] *)',\n  'a[href]:not([inert]):not([inert] *)',\n  'button:not([inert]):not([inert] *)',\n  '[tabindex]:not(slot):not([inert]):not([inert] *)',\n  'audio[controls]:not([inert]):not([inert] *)',\n  'video[controls]:not([inert]):not([inert] *)',\n  '[contenteditable]:not([contenteditable=\"false\"]):not([inert]):not([inert] *)',\n  'details>summary:first-of-type:not([inert]):not([inert] *)',\n  'details:not([inert]):not([inert] *)',\n];\nconst candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');\n\nconst NoElement = typeof Element === 'undefined';\n\nconst matches = NoElement\n  ? function () {}\n  : Element.prototype.matches ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\n\nconst getRootNode =\n  !NoElement && Element.prototype.getRootNode\n    ? (element) => element?.getRootNode?.()\n    : (element) => element?.ownerDocument;\n\n/**\n * Determines if a node is inert or in an inert ancestor.\n * @param {Node} [node]\n * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\n *  see if any of them are inert. If false, only `node` itself is considered.\n * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\n *  False if `node` is falsy.\n */\nconst isInert = function (node, lookUp = true) {\n  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\n  //  JS API property; we have to check the attribute, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's an active element\n  const inertAtt = node?.getAttribute?.('inert');\n  const inert = inertAtt === '' || inertAtt === 'true';\n\n  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\n  //  if it weren't for `matches()` not being a function on shadow roots; the following\n  //  code works for any kind of node\n  const result =\n    inert ||\n    (lookUp &&\n      node &&\n      // closest does not exist on shadow roots, so we fall back to a manual\n      // lookup upward, in case it is not defined.\n      (typeof node.closest === 'function'\n        ? node.closest('[inert]')\n        : isInert(node.parentNode)));\n\n  return result;\n};\n\n/**\n * Determines if a node's content is editable.\n * @param {Element} [node]\n * @returns True if it's content-editable; false if it's not or `node` is falsy.\n */\nconst isContentEditable = function (node) {\n  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\n  //  to use the attribute directly to check for this, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's a non-editable element\n  const attValue = node?.getAttribute?.('contenteditable');\n  return attValue === '' || attValue === 'true';\n};\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nconst getCandidates = function (el, includeContainer, filter) {\n  // even if `includeContainer=false`, we still have to check it for inertness because\n  //  if it's inert (either by itself or via its parent), then all its children are inert\n  if (isInert(el)) {\n    return [];\n  }\n\n  let candidates = Array.prototype.slice.apply(\n    el.querySelectorAll(candidateSelector)\n  );\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nconst getCandidatesIteratively = function (\n  elements,\n  includeContainer,\n  options\n) {\n  const candidates = [];\n  const elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    const element = elementsToCheck.shift();\n    if (isInert(element, false)) {\n      // no need to look up since we're drilling down\n      // anything inside this container will also be inert\n      continue;\n    }\n\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      const assigned = element.assignedElements();\n      const content = assigned.length ? assigned : element.children;\n      const nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push(...nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates,\n        });\n      }\n    } else {\n      // check candidate element\n      const validCandidate = matches.call(element, candidateSelector);\n      if (\n        validCandidate &&\n        options.filter(element) &&\n        (includeContainer || !elements.includes(element))\n      ) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      const shadowRoot =\n        element.shadowRoot ||\n        // check for an undisclosed shadow\n        (typeof options.getShadowRoot === 'function' &&\n          options.getShadowRoot(element));\n\n      // no inert look up because we're already drilling down and checking for inertness\n      //  on the way down, so all containers to this root node should have already been\n      //  vetted as non-inert\n      const validShadowRoot =\n        !isInert(shadowRoot, false) &&\n        (!options.shadowRootFilter || options.shadowRootFilter(element));\n\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        const nestedCandidates = getCandidatesIteratively(\n          shadowRoot === true ? element.children : shadowRoot.children,\n          true,\n          options\n        );\n\n        if (options.flatten) {\n          candidates.push(...nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: nestedCandidates,\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift(...element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\n/**\n * @private\n * Determines if the node has an explicitly specified `tabindex` attribute.\n * @param {HTMLElement} node\n * @returns {boolean} True if so; false if not.\n */\nconst hasTabIndex = function (node) {\n  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));\n};\n\n/**\n * Determine the tab index of a given node.\n * @param {HTMLElement} node\n * @returns {number} Tab order (negative, 0, or positive number).\n * @throws {Error} If `node` is falsy.\n */\nconst getTabIndex = function (node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    if (\n      (/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) ||\n        isContentEditable(node)) &&\n      !hasTabIndex(node)\n    ) {\n      return 0;\n    }\n  }\n\n  return node.tabIndex;\n};\n\n/**\n * Determine the tab index of a given node __for sort order purposes__.\n * @param {HTMLElement} node\n * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\n *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\n *  inserted into the correct sort position.\n * @returns {number} Tab order (negative, 0, or positive number).\n */\nconst getSortOrderTabIndex = function (node, isScope) {\n  const tabIndex = getTabIndex(node);\n\n  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\n    return 0;\n  }\n\n  return tabIndex;\n};\n\nconst sortOrderedTabbables = function (a, b) {\n  return a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex;\n};\n\nconst isInput = function (node) {\n  return node.tagName === 'INPUT';\n};\n\nconst isHiddenInput = function (node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nconst isDetailsWithSummary = function (node) {\n  const r =\n    node.tagName === 'DETAILS' &&\n    Array.prototype.slice\n      .apply(node.children)\n      .some((child) => child.tagName === 'SUMMARY');\n  return r;\n};\n\nconst getCheckedRadio = function (nodes, form) {\n  for (let i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nconst isTabbableRadio = function (node) {\n  if (!node.name) {\n    return true;\n  }\n  const radioScope = node.form || getRootNode(node);\n  const queryRadios = function (name) {\n    return radioScope.querySelectorAll(\n      'input[type=\"radio\"][name=\"' + name + '\"]'\n    );\n  };\n\n  let radioSet;\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.CSS !== 'undefined' &&\n    typeof window.CSS.escape === 'function'\n  ) {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s',\n        err.message\n      );\n      return false;\n    }\n  }\n\n  const checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nconst isRadio = function (node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nconst isNonTabbableRadio = function (node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nconst isNodeAttached = function (node) {\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\n  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\n  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\n  //  `ownerDocument` will be `null`, hence the optional chaining on it.\n  let nodeRoot = node && getRootNode(node);\n  let nodeRootHost = nodeRoot?.host;\n\n  // in some cases, a detached node will return itself as the root instead of a document or\n  //  shadow root object, in which case, we shouldn't try to look further up the host chain\n  let attached = false;\n  if (nodeRoot && nodeRoot !== node) {\n    attached = !!(\n      nodeRootHost?.ownerDocument?.contains(nodeRootHost) ||\n      node?.ownerDocument?.contains(node)\n    );\n\n    while (!attached && nodeRootHost) {\n      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n      //  which means we need to get the host's host and check if that parent host is contained\n      //  in (i.e. attached to) the document\n      nodeRoot = getRootNode(nodeRootHost);\n      nodeRootHost = nodeRoot?.host;\n      attached = !!nodeRootHost?.ownerDocument?.contains(nodeRootHost);\n    }\n  }\n\n  return attached;\n};\n\nconst isZeroArea = function (node) {\n  const { width, height } = node.getBoundingClientRect();\n  return width === 0 && height === 0;\n};\nconst isHidden = function (node, { displayCheck, getShadowRoot }) {\n  if (displayCheck === 'full-native') {\n    if ('checkVisibility' in node) {\n      // Chrome >= 105, Edge >= 105, Firefox >= 106, Safari >= 17.4\n      // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/checkVisibility#browser_compatibility\n      const visible = node.checkVisibility({\n        // Checking opacity might be desirable for some use cases, but natively,\n        // opacity zero elements _are_ focusable and tabbable.\n        checkOpacity: false,\n        opacityProperty: false,\n\n        contentVisibilityAuto: true,\n        visibilityProperty: true,\n        // This is an alias for `visibilityProperty`. Contemporary browsers\n        // support both. However, this alias has wider browser support (Chrome\n        // >= 105 and Firefox >= 106, vs. Chrome >= 121 and Firefox >= 122), so\n        // we include it anyway.\n        checkVisibilityCSS: true,\n      });\n      return !visible;\n    }\n    // Fall through to manual visibility checks\n  }\n\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  const isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  const nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n\n  if (\n    !displayCheck ||\n    displayCheck === 'full' ||\n    // full-native can run this branch when it falls through in case\n    // Element#checkVisibility is unsupported\n    displayCheck === 'full-native' ||\n    displayCheck === 'legacy-full'\n  ) {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      const originalNode = node;\n      while (node) {\n        const parentElement = node.parentElement;\n        const rootNode = getRootNode(node);\n        if (\n          parentElement &&\n          !parentElement.shadowRoot &&\n          getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nconst isDisabledFromFieldset = function (node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    let parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (let i = 0; i < parentNode.children.length; i++) {\n          const child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *')\n              ? true\n              : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\n\nconst isNodeMatchingSelectorFocusable = function (options, node) {\n  if (\n    node.disabled ||\n    isHiddenInput(node) ||\n    isHidden(node, options) ||\n    // For a details element with a summary, the summary element gets the focus\n    isDetailsWithSummary(node) ||\n    isDisabledFromFieldset(node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isNodeMatchingSelectorTabbable = function (options, node) {\n  if (\n    isNonTabbableRadio(node) ||\n    getTabIndex(node) < 0 ||\n    !isNodeMatchingSelectorFocusable(options, node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isShadowRootTabbable = function (shadowHostNode) {\n  const tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nconst sortByOrder = function (candidates) {\n  const regularTabbables = [];\n  const orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    const isScope = !!item.scopeParent;\n    const element = isScope ? item.scopeParent : item;\n    const candidateTabindex = getSortOrderTabIndex(element, isScope);\n    const elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope\n        ? regularTabbables.push(...elements)\n        : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements,\n      });\n    }\n  });\n\n  return orderedTabbables\n    .sort(sortOrderedTabbables)\n    .reduce((acc, sortable) => {\n      sortable.isScope\n        ? acc.push(...sortable.content)\n        : acc.push(sortable.content);\n      return acc;\n    }, [])\n    .concat(regularTabbables);\n};\n\nconst tabbable = function (container, options) {\n  options = options || {};\n\n  let candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively(\n      [container],\n      options.includeContainer,\n      {\n        filter: isNodeMatchingSelectorTabbable.bind(null, options),\n        flatten: false,\n        getShadowRoot: options.getShadowRoot,\n        shadowRootFilter: isShadowRootTabbable,\n      }\n    );\n  } else {\n    candidates = getCandidates(\n      container,\n      options.includeContainer,\n      isNodeMatchingSelectorTabbable.bind(null, options)\n    );\n  }\n  return sortByOrder(candidates);\n};\n\nconst focusable = function (container, options) {\n  options = options || {};\n\n  let candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively(\n      [container],\n      options.includeContainer,\n      {\n        filter: isNodeMatchingSelectorFocusable.bind(null, options),\n        flatten: true,\n        getShadowRoot: options.getShadowRoot,\n      }\n    );\n  } else {\n    candidates = getCandidates(\n      container,\n      options.includeContainer,\n      isNodeMatchingSelectorFocusable.bind(null, options)\n    );\n  }\n\n  return candidates;\n};\n\nconst isTabbable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nconst focusableCandidateSelector = /* #__PURE__ */ candidateSelectors\n  .concat('iframe:not([inert]):not([inert] *)')\n  .join(',');\n\nconst isFocusable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { tabbable, focusable, isTabbable, isFocusable, getTabIndex };\n", "import { tabbable } from 'tabbable';\nimport { activeElement, contains, getDocument } from \"./element.js\";\nexport const getTabbableOptions = () => ({\n  getShadowRoot: true,\n  displayCheck:\n  // JSDOM does not support the `tabbable` library. To solve this we can\n  // check if `ResizeObserver` is a real function (not polyfilled), which\n  // determines if the current environment is JSDOM-like.\n  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n});\nfunction getTabbableIn(container, dir) {\n  const list = tabbable(container, getTabbableOptions());\n  const len = list.length;\n  if (len === 0) {\n    return undefined;\n  }\n  const active = activeElement(getDocument(container));\n  const index = list.indexOf(active);\n  // eslint-disable-next-line no-nested-ternary\n  const nextIndex = index === -1 ? dir === 1 ? 0 : len - 1 : index + dir;\n  return list[nextIndex];\n}\nexport function getNextTabbable(referenceElement) {\n  return getTabbableIn(getDocument(referenceElement).body, 1) || referenceElement;\n}\nexport function getPreviousTabbable(referenceElement) {\n  return getTabbableIn(getDocument(referenceElement).body, -1) || referenceElement;\n}\nfunction getTabbableNearElement(referenceElement, dir) {\n  if (!referenceElement) {\n    return null;\n  }\n  const list = tabbable(getDocument(referenceElement).body, getTabbableOptions());\n  const elementCount = list.length;\n  if (elementCount === 0) {\n    return null;\n  }\n  const index = list.indexOf(referenceElement);\n  if (index === -1) {\n    return null;\n  }\n  const nextIndex = (index + dir + elementCount) % elementCount;\n  return list[nextIndex];\n}\nexport function getTabbableAfterElement(referenceElement) {\n  return getTabbableNearElement(referenceElement, 1);\n}\nexport function getTabbableBeforeElement(referenceElement) {\n  return getTabbableNearElement(referenceElement, -1);\n}\nexport function isOutsideEvent(event, container) {\n  const containerElement = container || event.currentTarget;\n  const relatedTarget = event.relatedTarget;\n  return !relatedTarget || !contains(containerElement, relatedTarget);\n}\nexport function disableFocusInside(container) {\n  const tabbableElements = tabbable(container, getTabbableOptions());\n  tabbableElements.forEach(element => {\n    element.dataset.tabindex = element.getAttribute('tabindex') || '';\n    element.setAttribute('tabindex', '-1');\n  });\n}\nexport function enableFocusInside(container) {\n  const elements = container.querySelectorAll('[data-tabindex]');\n  elements.forEach(element => {\n    const tabindex = element.dataset.tabindex;\n    delete element.dataset.tabindex;\n    if (tabindex) {\n      element.setAttribute('tabindex', tabindex);\n    } else {\n      element.removeAttribute('tabindex');\n    }\n  });\n}", "export const none = 'none';\nexport const triggerPress = 'trigger-press';\nexport const triggerHover = 'trigger-hover';\nexport const triggerFocus = 'trigger-focus';\nexport const outsidePress = 'outside-press';\nexport const itemPress = 'item-press';\nexport const closePress = 'close-press';\nexport const linkPress = 'link-press';\nexport const clearPress = 'clear-press';\nexport const chipRemovePress = 'chip-remove-press';\nexport const trackPress = 'track-press';\nexport const incrementPress = 'increment-press';\nexport const decrementPress = 'decrement-press';\nexport const inputChange = 'input-change';\nexport const inputClear = 'input-clear';\nexport const inputBlur = 'input-blur';\nexport const inputPaste = 'input-paste';\nexport const focusOut = 'focus-out';\nexport const escapeKey = 'escape-key';\nexport const listNavigation = 'list-navigation';\nexport const keyboard = 'keyboard';\nexport const pointer = 'pointer';\nexport const drag = 'drag';\nexport const wheel = 'wheel';\nexport const scrub = 'scrub';\nexport const cancelOpen = 'cancel-open';\nexport const siblingOpen = 'sibling-open';\nexport const disabled = 'disabled';\nexport const imperativeAction = 'imperative-action';\nexport const windowResize = 'window-resize';", "import { EMPTY_OBJECT } from \"./constants.js\";\nimport { REASONS } from \"./reasons.js\";\n\n/**\n * Maps a change `reason` string to the corresponding native event type.\n */\n\n/**\n * Details of custom change events emitted by Base UI components.\n */\n\n/**\n * Details of custom generic events emitted by Base UI components.\n */\n\n/**\n * Creates a Base UI event details object with the given reason and utilities\n * for preventing Base UI's internal event handling.\n */\nexport function createChangeEventDetails(reason, event, trigger, customProperties) {\n  let canceled = false;\n  let allowPropagation = false;\n  const custom = customProperties ?? EMPTY_OBJECT;\n  const details = {\n    reason,\n    event: event ?? new Event('base-ui'),\n    cancel() {\n      canceled = true;\n    },\n    allowPropagation() {\n      allowPropagation = true;\n    },\n    get isCanceled() {\n      return canceled;\n    },\n    get isPropagationAllowed() {\n      return allowPropagation;\n    },\n    trigger,\n    ...custom\n  };\n  return details;\n}\nexport function createGenericEventDetails(reason, event, customProperties) {\n  const custom = customProperties ?? EMPTY_OBJECT;\n  const details = {\n    reason,\n    event: event ?? new Event('base-ui'),\n    ...custom\n  };\n  return details;\n}", "'use client';\n\nimport * as React from 'react';\nconst EMPTY = [];\n\n/**\n * A React.useEffect equivalent that runs once, when the component is mounted.\n */\nexport function useOnMount(fn) {\n  // TODO: uncomment once we enable eslint-plugin-react-compiler // eslint-disable-next-line react-compiler/react-compiler -- no need to put `fn` in the dependency array\n  /* eslint-disable react-hooks/exhaustive-deps */\n  React.useEffect(fn, EMPTY);\n  /* eslint-enable react-hooks/exhaustive-deps */\n}", "'use client';\n\nimport { useRefWithInit } from \"./useRefWithInit.js\";\nimport { useOnMount } from \"./useOnMount.js\";\nconst EMPTY = 0;\nexport class Timeout {\n  static create() {\n    return new Timeout();\n  }\n  currentId = EMPTY;\n\n  /**\n   * Executes `fn` after `delay`, clearing any previously scheduled call.\n   */\n  start(delay, fn) {\n    this.clear();\n    this.currentId = setTimeout(() => {\n      this.currentId = EMPTY;\n      fn();\n    }, delay); /* Node.js types are enabled in development */\n  }\n  isStarted() {\n    return this.currentId !== EMPTY;\n  }\n  clear = () => {\n    if (this.currentId !== EMPTY) {\n      clearTimeout(this.currentId);\n      this.currentId = EMPTY;\n    }\n  };\n  disposeEffect = () => {\n    return this.clear;\n  };\n}\n\n/**\n * A `setTimeout` with automatic cleanup and guard.\n */\nexport function useTimeout() {\n  const timeout = useRefWithInit(Timeout.create).current;\n  useOnMount(timeout.disposeEffect);\n  return timeout;\n}", "export { getWindow as ownerWindow } from '@floating-ui/utils/dom';\nexport function ownerDocument(node) {\n  return node?.ownerDocument || document;\n}"],
  "mappings": "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",
  "names": ["React", "candidateSelectors", "candidateSelector", "join", "NoElement", "Element", "matches", "prototype", "msMatchesSelector", "webkitMatchesSelector", "getRootNode", "element", "_element$getRootNode", "call", "ownerDocument", "isInert", "node", "lookUp", "_node$getAttribute", "inertAtt", "getAttribute", "inert", "result", "closest", "parentNode", "isContentEditable", "_node$getAttribute2", "attValue", "getCandidates", "el", "includeContainer", "filter", "candidates", "Array", "slice", "apply", "querySelectorAll", "unshift", "getCandidatesIteratively", "elements", "options", "elementsToCheck", "from", "length", "shift", "tagName", "assigned", "assignedElements", "content", "children", "nestedCandidates", "flatten", "push", "scopeParent", "validCandidate", "includes", "shadowRoot", "getShadowRoot", "validShadowRoot", "shadowRootFilter", "hasTabIndex", "isNaN", "parseInt", "getTabIndex", "Error", "tabIndex", "test", "getSortOrderTabIndex", "isScope", "sortOrderedTabbables", "a", "b", "documentOrder", "isInput", "isHiddenInput", "type", "isDetailsWithSummary", "r", "some", "child", "getCheckedRadio", "nodes", "form", "i", "checked", "isTabbableRadio", "name", "radioScope", "queryRadios", "radioSet", "window", "CSS", "escape", "err", "console", "error", "message", "isRadio", "isNonTabbableRadio", "isNodeAttached", "_nodeRoot", "nodeRoot", "nodeRootHost", "host", "attached", "_nodeRootHost", "_nodeRootHost$ownerDo", "_node$ownerDocument", "contains", "_nodeRoot2", "_nodeRootHost2", "_nodeRootHost2$ownerD", "isZeroArea", "_node$getBoundingClie", "getBoundingClientRect", "width", "height", "isHidden", "_ref", "displayCheck", "visible", "checkVisibility", "checkOpacity", "opacityProperty", "contentVisibilityAuto", "visibilityProperty", "checkVisibilityCSS", "getComputedStyle", "visibility", "isDirectSummary", "nodeUnderDetails", "parentElement", "originalNode", "rootNode", "assignedSlot", "getClientRects", "isDisabledFromFieldset", "disabled", "item", "isNodeMatchingSelectorFocusable", "isNodeMatchingSelectorTabbable", "isShadowRootTabbable", "shadowHostNode", "sortByOrder", "regularTabbables", "orderedTabbables", "forEach", "candidateTabindex", "sort", "reduce", "acc", "sortable", "concat", "tabbable", "container", "bind", "focusable", "isTabbable", "focusableCandidateSelector", "React", "EMPTY"]
}
